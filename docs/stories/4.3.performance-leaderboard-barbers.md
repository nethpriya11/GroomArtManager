# Story 4.3: Performance Leaderboard - Top Barbers

## Status

Draft

## Story

**As a** manager,
**I want** to see which barbers are generating the most revenue,
**so that** I can recognize top performers and identify training needs.

## Acceptance Criteria

1. Reports page includes "Top Barbers" leaderboard table below KPIs
2. Table columns: Rank (#1, #2, #3...), Barber (name), Services (count), Revenue ($XXX.XX)
3. Data aggregated from service logs: Group by barberId, sum prices, count logs (status = approved, within date range)
4. Sorted by revenue descending (highest earner at #1)
5. Top 10 barbers displayed by default
6. "View All" button expands to show all barbers
7. Real-time updates: Rankings shift when new services approved
8. Avatar displayed next to barber name (if available)
9. Clicking a barber row could drill down to their individual report (stretch goal - not required for MVP)
10. Empty state if no data: "No services logged in selected date range"

## Tasks / Subtasks

- [ ] Create barber leaderboard aggregation function (AC: 3, 4)
  - [ ] Implement `getTopBarbers(dateRange, limit)` in `lib/services/reporting-service.ts`
  - [ ] Query serviceLogs where status='approved' within date range
  - [ ] Group by barberId using Map or reduce operation
  - [ ] For each barber: calculate total revenue (sum prices) and service count
  - [ ] Sort by revenue descending
  - [ ] Return top N barbers (default 10, expandable to all)
  - [ ] Include barber details: id, name, avatar, revenue, serviceCount
- [ ] Create custom hook for real-time barber leaderboard (AC: 7)
  - [ ] Implement `useTopBarbers(dateRange, limit)` in `hooks/useTopBarbers.ts`
  - [ ] Wrap `getTopBarbers()` with React Query and onSnapshot listener
  - [ ] Re-query when date range changes or limit changes
  - [ ] Handle real-time ranking updates when services approved
  - [ ] Configure staleTime: Infinity for real-time data
- [ ] Build leaderboard table component (AC: 1, 2, 5, 8)
  - [ ] Create `TopBarbersTable.tsx` in `components/reports/`
  - [ ] Define table columns: Rank, Barber (name + avatar), Services (count), Revenue
  - [ ] Use ShadCN Table component for styling
  - [ ] Display rank as #1, #2, #3, etc.
  - [ ] Show barber avatar next to name (fallback to initials if no avatar)
  - [ ] Format revenue as currency ($XXX.XX)
  - [ ] Limit to top 10 by default
- [ ] Implement "View All" expansion (AC: 5, 6)
  - [ ] Add "View All" button below table
  - [ ] Toggle limit between 10 and unlimited on button click
  - [ ] Button text changes to "Show Top 10" when expanded
  - [ ] Smooth transition when expanding/collapsing
- [ ] Integrate leaderboard into reports page (AC: 1)
  - [ ] Add TopBarbersTable below financial KPI cards in `app/manager/reports/page.tsx`
  - [ ] Pass selected date range to table component
  - [ ] Position for desktop side-by-side layout (Story 4.4)
- [ ] Handle empty state (AC: 10)
  - [ ] Display "No services logged in selected date range" when no data
  - [ ] Show empty state component (not error)
  - [ ] Maintain table structure with empty message
- [ ] Implement loading state (AC: 7)
  - [ ] Create skeleton loader for table rows
  - [ ] Show 10 skeleton rows while data loading
  - [ ] Use ShadCN Skeleton component
- [ ] Test real-time ranking updates (AC: 7)
  - [ ] Approve service log for barber, verify ranking updates
  - [ ] Test ranking shift when multiple barbers updated
  - [ ] Verify updates appear within <2s latency
- [ ] Implement optional drill-down (AC: 9)
  - [ ] Add click handler to table rows (stretch goal)
  - [ ] Navigate to individual barber report page (not required for MVP)
  - [ ] Document as future enhancement if not implemented

## Dev Notes

### Barber Leaderboard Aggregation

[Source: architecture.md#Reporting & Analytics Service]

The `getTopBarbers()` function aggregates service logs by barber and ranks them by revenue:

**Implementation Pattern:**

```typescript
export async function getTopBarbers(
  dateRange: DateRange,
  limit: number = 10
): Promise<BarberLeaderboardEntry[]> {
  const db = getFirestore()

  // Query approved logs within date range
  const logsQuery = query(
    collection(db, 'serviceLogs'),
    where('status', '==', 'approved'),
    where('createdAt', '>=', Timestamp.fromDate(dateRange.from)),
    where('createdAt', '<=', Timestamp.fromDate(dateRange.to))
  )

  const snapshot = await getDocs(logsQuery)

  // Group by barberId
  const barberStats = new Map<
    string,
    { revenue: number; serviceCount: number }
  >()

  snapshot.docs.forEach((doc) => {
    const log = doc.data()
    const existing = barberStats.get(log.barberId) || {
      revenue: 0,
      serviceCount: 0,
    }
    barberStats.set(log.barberId, {
      revenue: existing.revenue + log.price,
      serviceCount: existing.serviceCount + 1,
    })
  })

  // Fetch barber details and combine with stats
  const barberEntries = await Promise.all(
    Array.from(barberStats.entries()).map(async ([barberId, stats]) => {
      const barberDoc = await getDoc(doc(db, 'users', barberId))
      const barber = barberDoc.data() as UserProfile
      return {
        barberId,
        barberName: barber.username,
        barberAvatar: barber.avatarUrl,
        revenue: stats.revenue,
        serviceCount: stats.serviceCount,
      }
    })
  )

  // Sort by revenue descending and limit
  return barberEntries.sort((a, b) => b.revenue - a.revenue).slice(0, limit)
}
```

### Real-time Updates

[Source: architecture.md#Real-time Sync Engine]

Use onSnapshot listener to detect ranking changes:

```typescript
export function useTopBarbers(dateRange: DateRange, limit: number = 10) {
  return useQuery({
    queryKey: ['top-barbers', dateRange.from, dateRange.to, limit],
    queryFn: () =>
      new Promise((resolve) => {
        const logsQuery = query(
          collection(db, 'serviceLogs'),
          where('status', '==', 'approved'),
          where('createdAt', '>=', Timestamp.fromDate(dateRange.from)),
          where('createdAt', '<=', Timestamp.fromDate(dateRange.to))
        )

        const unsubscribe = onSnapshot(logsQuery, async (snapshot) => {
          // Recalculate leaderboard on each update
          const leaderboard = await calculateLeaderboardFromSnapshot(
            snapshot,
            limit
          )
          resolve(leaderboard)
        })

        return () => unsubscribe()
      }),
    staleTime: Infinity,
  })
}
```

### Data Models

[Source: architecture.md#Data Models]

**ServiceLog:**

- `barberId`: string - References user ID
- `price`: number - Used for revenue calculation
- `status`: 'pending' | 'approved' | 'rejected'
- `createdAt`: Firestore Timestamp

**UserProfile:**

- `username`: string - Barber display name
- `avatarUrl`: string | null - Profile image
- `role`: 'manager' | 'barber'

### Composite Index Required

[Source: architecture.md#Database Schema]

Same index as financial KPIs for date-filtered approved logs:

```json
{
  "collectionGroup": "serviceLogs",
  "fields": [
    { "fieldPath": "status", "order": "ASCENDING" },
    { "fieldPath": "createdAt", "order": "DESCENDING" }
  ]
}
```

### Component Structure

Follow atomic design pattern:

- **Molecules:** LeaderboardRow (single barber entry with avatar, name, stats)
- **Organisms:** TopBarbersTable (complete leaderboard table)
- **Templates:** Reports page layout with leaderboards

### Avatar Display

- If `avatarUrl` exists: Display image in circle (40x40px)
- If `avatarUrl` is null: Show initials in colored circle (use first 2 letters of username)
- Use consistent styling with barber cards from other pages

### Table Styling

- Use ShadCN Table component for consistency
- Dark theme: #1a1a1a background, #f59e0b accents for top 3 ranks
- Rank column: Bold font, highlight #1, #2, #3 with accent color
- Revenue column: Right-aligned, formatted as currency
- Services column: Right-aligned, formatted as number

### Testing

[Source: architecture.md#Testing Strategy]

#### Component Tests

**Location:** `tests/component/reports/TopBarbersTable.test.tsx`

Test cases:

1. Renders table with correct columns
2. Displays barber avatar and name
3. Formats revenue as currency
4. Shows rank numbers correctly (#1, #2, #3)
5. Limits to top 10 by default
6. "View All" button expands to show all barbers
7. Displays empty state when no data
8. Shows loading skeleton while fetching

**Example:**

```typescript
describe('TopBarbersTable', () => {
  it('displays top barbers ranked by revenue', () => {
    const mockData = [
      { barberId: '1', barberName: 'John', barberAvatar: null, revenue: 1000, serviceCount: 20 },
      { barberId: '2', barberName: 'Jane', barberAvatar: 'url', revenue: 800, serviceCount: 15 },
    ];

    render(<TopBarbersTable data={mockData} />);

    // Verify rank order
    expect(screen.getByText('#1')).toBeInTheDocument();
    expect(screen.getByText('#2')).toBeInTheDocument();

    // Verify revenue formatting
    expect(screen.getByText('$1,000.00')).toBeInTheDocument();
    expect(screen.getByText('$800.00')).toBeInTheDocument();
  });

  it('expands to show all barbers when "View All" clicked', async () => {
    const mockData = Array.from({ length: 15 }, (_, i) => ({
      barberId: `${i}`,
      barberName: `Barber ${i}`,
      barberAvatar: null,
      revenue: 1000 - i * 50,
      serviceCount: 10,
    }));

    render(<TopBarbersTable data={mockData} />);

    // Initially shows 10
    expect(screen.getAllByRole('row')).toHaveLength(11); // 10 data + 1 header

    // Click "View All"
    await userEvent.click(screen.getByText('View All'));

    // Now shows all 15
    expect(screen.getAllByRole('row')).toHaveLength(16); // 15 data + 1 header
  });
});
```

#### Integration Tests

**Location:** `tests/component/reports/ReportsPage.test.tsx`

Test cases:

1. Leaderboard updates when date range changes
2. Rankings recalculated when new services approved
3. Leaderboard syncs with financial KPIs (same data source)

#### E2E Tests

**Location:** `tests/e2e/reports.spec.ts`

Test cases:

1. Manager views reports page with barber leaderboard
2. Verify top 10 barbers displayed
3. Click "View All", verify all barbers shown
4. Approve service log, verify rankings update in real-time
5. Change date range, verify leaderboard updates

**Test Flow:**

```typescript
test('Barber leaderboard shows real-time ranking updates', async ({
  page,
  context,
}) => {
  await page.goto('/manager/reports')

  // Verify leaderboard loaded
  await expect(page.locator('[data-testid="top-barbers-table"]')).toBeVisible()

  // Record rank #1 barber
  const topBarber = await page
    .locator('[data-testid="barber-rank-1-name"]')
    .textContent()

  // Open second browser to approve service for different barber
  const page2 = await context.newPage()
  await page2.goto('/manager/approvals')
  await page2.click('[data-testid="approve-log-btn-barber-2"]') // Approve multiple for barber #2

  // Verify rankings shifted on first page within 2 seconds
  await expect(
    page.locator('[data-testid="barber-rank-1-name"]')
  ).not.toHaveText(topBarber, { timeout: 2000 })
})
```

#### Unit Tests

**Location:** `tests/unit/services/reporting-service.test.ts`

Test cases:

1. `getTopBarbers()` groups logs by barberId correctly
2. Calculates total revenue per barber (sum of prices)
3. Counts services per barber correctly
4. Sorts barbers by revenue descending
5. Limits to top N barbers
6. Fetches barber details (name, avatar) from users collection
7. Filters only approved logs within date range
8. Returns empty array when no logs in range

**Example:**

```typescript
describe('getTopBarbers', () => {
  it('ranks barbers by revenue descending', async () => {
    // Mock service logs
    mockGetDocs.mockResolvedValue({
      docs: [
        {
          data: () => ({ barberId: 'barber1', price: 100, status: 'approved' }),
        },
        {
          data: () => ({ barberId: 'barber2', price: 150, status: 'approved' }),
        },
        {
          data: () => ({ barberId: 'barber1', price: 50, status: 'approved' }),
        },
      ],
    })

    // Mock barber profiles
    mockGetDoc.mockImplementation((docRef) => {
      if (docRef.id === 'barber1') {
        return Promise.resolve({
          data: () => ({ username: 'John', avatarUrl: null }),
        })
      }
      return Promise.resolve({
        data: () => ({ username: 'Jane', avatarUrl: 'url' }),
      })
    })

    const dateRange = { from: subDays(new Date(), 7), to: new Date() }
    const leaderboard = await getTopBarbers(dateRange, 10)

    // Verify ranking
    expect(leaderboard[0].barberId).toBe('barber2') // $150
    expect(leaderboard[0].revenue).toBe(150)
    expect(leaderboard[1].barberId).toBe('barber1') // $150 total
    expect(leaderboard[1].revenue).toBe(150)
    expect(leaderboard[1].serviceCount).toBe(2)
  })
})
```

## Change Log

| Date       | Version | Description            | Author          |
| ---------- | ------- | ---------------------- | --------------- |
| 2025-10-10 | v1.0    | Initial story creation | PM Agent (John) |

## Dev Agent Record

### Agent Model Used

{To be populated by dev agent}

### Debug Log References

{To be populated by dev agent}

### Completion Notes List

{To be populated by dev agent}

### File List

{To be populated by dev agent}

## QA Results

{To be populated by QA agent}
