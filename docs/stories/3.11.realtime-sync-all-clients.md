# Story 3.11: Real-time Sync Across All Clients

## Status

Draft

## Story

**As a** manager or barber,
**I want** all data changes to appear instantly across all open browser windows,
**so that** multiple users can work simultaneously without confusion.

## Acceptance Criteria

1. Manager dashboard "Pending Approvals" table uses onSnapshot listener (updates in real-time)
2. Barber dashboard "My Logged Services" table uses onSnapshot listener
3. Barber daily stats use onSnapshot listener on serviceLogs filtered by barberId
4. When barber logs a service: Manager dashboard shows new pending log within 2 seconds
5. When manager approves a service: Barber dashboard status changes to "Approved" within 2 seconds, daily stats increment
6. Multiple managers can approve different logs simultaneously without conflicts
7. Optimistic UI updates used for user actions (approve, reject, log) with rollback on error
8. Network latency simulated in E2E tests (throttle to 3G) to verify updates still propagate
9. Animations for real-time updates: New rows fade in (200ms), status changes pulse highlight (green for approve)
10. No polling or manual refresh required - all updates pushed via Firestore listeners

## Tasks / Subtasks

- [ ] Create useRealtimeQuery custom hook (AC: 1, 2, 3, 10)
  - [ ] Create hook in hooks/useRealtimeQuery.ts
  - [ ] Wrap Firestore onSnapshot in React Query useQuery
  - [ ] Set staleTime: Infinity (real-time data never stale)
  - [ ] Handle subscription cleanup in return function
  - [ ] Add error handling for listener failures
  - [ ] Export hook for use in components
- [ ] Implement manager pending approvals real-time listener (AC: 1, 4)
  - [ ] Create useServiceLogs hook with status filter
  - [ ] Query: where('status', '==', 'pending')
  - [ ] Sort by createdAt ascending (FIFO queue)
  - [ ] Use in ManagerPendingApprovalsTable component
  - [ ] Verify new logs appear within 2 seconds
- [ ] Implement barber service logs real-time listener (AC: 2, 5)
  - [ ] Query: where('barberId', '==', currentUserId)
  - [ ] Sort by createdAt descending (newest first)
  - [ ] Use in BarberServiceLogTable component
  - [ ] Listen for status field changes (pending â†’ approved/rejected)
  - [ ] Verify status updates within 2 seconds
- [ ] Implement barber daily stats real-time listener (AC: 3, 5)
  - [ ] Query: where('barberId', '==', currentUserId) AND where('status', '==', 'approved') AND where('createdAt', '>=', startOfToday)
  - [ ] Calculate count of logs for services count
  - [ ] Sum commissionAmount for revenue
  - [ ] Use in BarberDailyStatsCard component
  - [ ] Verify stats increment when manager approves
- [ ] Handle concurrent updates safely (AC: 6)
  - [ ] Use Firestore transactions for approval/rejection
  - [ ] Test: Two managers approve different logs simultaneously
  - [ ] Verify no conflicts or lost updates
  - [ ] Ensure each log can only be approved once
  - [ ] Add optimistic locking if needed
- [ ] Implement real-time update animations (AC: 9)
  - [ ] Add fade-in animation for new table rows (200ms)
  - [ ] Add pulse highlight animation for status changes (green for approve, red for reject)
  - [ ] Use Tailwind animate-pulse or custom CSS animation
  - [ ] Trigger animation on data change detection
  - [ ] Test animations don't block UI interactions
- [ ] Add Firestore composite indexes (AC: 4, 5)
  - [ ] Create firestore.indexes.json file
  - [ ] Index: (status ASC, createdAt ASC) for pending queue
  - [ ] Index: (barberId ASC, createdAt DESC) for barber history
  - [ ] Index: (barberId ASC, status ASC, createdAt DESC) for barber stats
  - [ ] Deploy indexes with Firebase CLI
- [ ] Write E2E tests for real-time sync (AC: 4, 5, 8)
  - [ ] Test: Barber logs service, manager sees it within 2s
  - [ ] Test: Manager approves, barber sees status change within 2s
  - [ ] Test: Barber stats update when approval happens
  - [ ] Test: Network throttled to 3G, updates still propagate
  - [ ] Use Playwright multi-browser contexts

## Dev Notes

### Real-time Sync Engine Architecture

[Source: architecture.md#Components - Real-time Sync Engine]

The Real-time Sync Engine manages Firestore onSnapshot listeners with automatic subscription lifecycle, caching, and error handling using React Query.

**Key Interfaces:**

- `useRealtimeQuery(queryKey, firestoreQuery)` - Generic hook wrapping onSnapshot
- `useServices()` - Real-time service catalog
- `useServiceLogs(filters)` - Real-time service logs with filters
- `useBarbers()` - Real-time barber list

**Technology Stack:** React Query v5.40+, Firestore onSnapshot

### useRealtimeQuery Hook Implementation

[Source: architecture.md#Components - Real-time Sync Engine]

```typescript
// hooks/useRealtimeQuery.ts
import { useQuery, QueryKey } from '@tanstack/react-query'
import { Query, onSnapshot } from 'firebase/firestore'

export function useRealtimeQuery<T>(queryKey: QueryKey, firestoreQuery: Query) {
  return useQuery({
    queryKey,
    queryFn: () =>
      new Promise<T[]>((resolve, reject) => {
        const unsubscribe = onSnapshot(
          firestoreQuery,
          (snapshot) => {
            const data = snapshot.docs.map(
              (doc) =>
                ({
                  id: doc.id,
                  ...doc.data(),
                }) as T
            )
            resolve(data)
          },
          reject
        )
        // Cleanup: unsubscribe when query is unmounted
        return () => unsubscribe()
      }),
    staleTime: Infinity, // Real-time data never stale
    gcTime: 5 * 60 * 1000, // 5 minutes cache after unmount
  })
}
```

**Why staleTime: Infinity?** Real-time listeners keep data fresh automatically via onSnapshot. React Query should never refetch because Firestore pushes updates.

### Manager Pending Approvals Query

[Source: architecture.md#Database Schema - Composite Indexes]

```typescript
// hooks/useServiceLogs.ts
import { collection, query, where, orderBy } from 'firebase/firestore'
import { db } from '@/lib/firebase/config'
import { useRealtimeQuery } from './useRealtimeQuery'
import type { ServiceLog } from '@/types/firestore'

export function usePendingServiceLogs() {
  const q = query(
    collection(db, 'serviceLogs'),
    where('status', '==', 'pending'),
    orderBy('createdAt', 'asc') // FIFO queue
  )

  return useRealtimeQuery<ServiceLog>(['serviceLogs', 'pending'], q)
}
```

**Firestore Index Required:**

```json
{
  "collectionGroup": "serviceLogs",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "status", "order": "ASCENDING" },
    { "fieldPath": "createdAt", "order": "ASCENDING" }
  ]
}
```

### Barber Service Logs Query

[Source: architecture.md#Database Schema - Composite Indexes]

```typescript
export function useBarberServiceLogs(barberId: string) {
  const q = query(
    collection(db, 'serviceLogs'),
    where('barberId', '==', barberId),
    orderBy('createdAt', 'desc') // Newest first
  )

  return useRealtimeQuery<ServiceLog>(['serviceLogs', barberId], q)
}
```

**Firestore Index Required:**

```json
{
  "collectionGroup": "serviceLogs",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "barberId", "order": "ASCENDING" },
    { "fieldPath": "createdAt", "order": "DESCENDING" }
  ]
}
```

### Barber Daily Stats Query

[Source: architecture.md#Data Models - ServiceLog]

```typescript
import { startOfDay } from 'date-fns'

export function useBarberDailyStats(barberId: string) {
  const today = startOfDay(new Date())

  const q = query(
    collection(db, 'serviceLogs'),
    where('barberId', '==', barberId),
    where('status', '==', 'approved'),
    where('createdAt', '>=', today)
  )

  const { data: logs } = useRealtimeQuery<ServiceLog>(
    ['serviceLogs', barberId, 'daily'],
    q
  )

  return {
    servicesCount: logs?.length ?? 0,
    revenue: logs?.reduce((sum, log) => sum + log.commissionAmount, 0) ?? 0,
  }
}
```

**Firestore Index Required:**

```json
{
  "collectionGroup": "serviceLogs",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "barberId", "order": "ASCENDING" },
    { "fieldPath": "status", "order": "ASCENDING" },
    { "fieldPath": "createdAt", "order": "DESCENDING" }
  ]
}
```

### Real-time Synchronization Flow

[Source: architecture.md#Core Workflows - Workflow 3]

```mermaid
sequenceDiagram
    participant B as Barber Browser
    participant M1 as Manager Browser 1
    participant M2 as Manager Browser 2
    participant FS as Firestore

    Note over B,M1,M2: All clients have active onSnapshot listeners

    B->>FS: Create serviceLog (status='pending')

    Note over FS: Firestore triggers onSnapshot callbacks

    par Real-time push to both managers
        FS->>M1: Push new pending log (onSnapshot)
        FS->>M2: Push new pending log (onSnapshot)
    end

    M1->>M1: Animate new row in "Pending Approvals"
    M2->>M2: Animate new row in "Pending Approvals"

    M1->>FS: Approve log (status='approved')

    par Real-time push to all
        FS->>M2: Push status change (approved)
        FS->>B: Push status change (approved)
    end

    M2->>M2: Remove from pending queue (already approved by M1)
    B->>B: Update badge to "Approved", increment daily stats

    Note over B,M1,M2: <2s latency from action to update
```

### Concurrent Update Handling

[Source: architecture.md#Architectural Patterns - Optimistic UI Updates]

Firestore transactions ensure multiple managers can approve different logs simultaneously without conflicts:

```typescript
import { runTransaction, doc } from 'firebase/firestore'

export async function approveLog(logId: string) {
  const logRef = doc(db, 'serviceLogs', logId)

  await runTransaction(db, async (transaction) => {
    const logDoc = await transaction.get(logRef)

    if (!logDoc.exists()) {
      throw new Error('Service log not found')
    }

    if (logDoc.data().status !== 'pending') {
      throw new Error('Service log is not pending')
    }

    transaction.update(logRef, {
      status: 'approved',
      approvedAt: serverTimestamp(),
    })
  })
}
```

**Transaction Guarantees:**

- Atomic: All updates succeed or fail together
- Isolated: No interference from concurrent updates
- If two managers approve same log, second transaction fails gracefully

### Real-time Update Animations

[Source: architecture.md#Architectural Patterns - Real-time Data Synchronization]

```typescript
// components/features/service-logs/ServiceLogTable.tsx
import { motion } from 'framer-motion'; // Optional: for smooth animations

export function ServiceLogTable({ logs }: { logs: ServiceLog[] }) {
  return (
    <table>
      <tbody>
        {logs.map((log) => (
          <motion.tr
            key={log.id}
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            transition={{ duration: 0.2 }}
            className={log.status === 'approved' ? 'animate-pulse-once' : ''}
          >
            {/* Table cells */}
          </motion.tr>
        ))}
      </tbody>
    </table>
  );
}
```

**CSS Animation (Tailwind):**

```css
/* globals.css */
@keyframes pulse-once {
  0%,
  100% {
    background-color: transparent;
  }
  50% {
    background-color: rgba(34, 197, 94, 0.2);
  } /* green-500 with opacity */
}

.animate-pulse-once {
  animation: pulse-once 0.6s ease-in-out;
}
```

### Performance Considerations

[Source: architecture.md#Architectural Patterns - Real-time Data Synchronization]

**Listener Cleanup:** React Query automatically unsubscribes from onSnapshot when component unmounts, preventing memory leaks.

**Pagination:** If service logs exceed 100 rows, implement pagination to limit listener scope:

```typescript
const q = query(
  collection(db, 'serviceLogs'),
  where('barberId', '==', barberId),
  orderBy('createdAt', 'desc'),
  limit(50) // Page size
)
```

**Network Efficiency:** Firestore only sends changed documents (deltas), not entire result set, reducing bandwidth.

### Testing

**E2E Tests Required:**
[Source: architecture.md#Testing Strategy - E2E Tests]

1. **Multi-Client Real-time Sync Test** (`tests/e2e/real-time-sync.spec.ts`)
   - Open two browser contexts (barber + manager)
   - Barber logs a service
   - Verify manager's pending queue updates within 2 seconds
   - Verify fade-in animation plays for new row
   - Manager approves the log
   - Verify barber's table status changes to "Approved" within 2 seconds
   - Verify barber's daily stats increment (services count + revenue)
   - Verify pulse animation plays on status change

2. **Concurrent Manager Approvals Test** (`tests/e2e/concurrent-approvals.spec.ts`)
   - Open three browser contexts (barber + 2 managers)
   - Barber logs 5 services
   - Manager 1 approves log A
   - Manager 2 approves log B (simultaneously)
   - Verify both approvals succeed without conflict
   - Verify both managers see each other's approvals in real-time
   - Verify barber sees both approvals

3. **Network Latency Test** (`tests/e2e/network-latency.spec.ts`)
   - Use Playwright network throttling: `page.route('**/*', route => route.continue({ delay: 500 }))`
   - Simulate 3G network (slow 3G: 400ms RTT)
   - Barber logs a service
   - Verify manager receives update (may take >2s due to throttling)
   - Manager approves
   - Verify barber receives update
   - Verify no data loss or UI inconsistencies

4. **Listener Cleanup Test** (`tests/unit/hooks/useRealtimeQuery.test.ts`)
   - Mount component using useRealtimeQuery
   - Verify onSnapshot listener is active
   - Unmount component
   - Verify unsubscribe function called (no listener leaks)
   - Re-mount component
   - Verify new listener created

**Test Utilities:**

```typescript
// tests/utils/firebase-emulator.ts
export async function waitForRealtimeUpdate(
  callback: () => boolean,
  timeoutMs: number = 3000
) {
  const startTime = Date.now()
  while (Date.now() - startTime < timeoutMs) {
    if (callback()) return
    await new Promise((resolve) => setTimeout(resolve, 100))
  }
  throw new Error('Real-time update did not occur within timeout')
}
```

**Usage in E2E Test:**

```typescript
test('barber sees approval within 2 seconds', async ({
  barberPage,
  managerPage,
}) => {
  // Manager approves
  await managerPage.click('[aria-label="Approve"]')

  // Wait for real-time update
  await waitForRealtimeUpdate(
    () => barberPage.locator('text=Approved').isVisible(),
    2000
  )
})
```

## Change Log

| Date       | Version | Description            | Author          |
| ---------- | ------- | ---------------------- | --------------- |
| 2025-10-10 | v1.0    | Initial story creation | PM Agent (John) |

## Dev Agent Record

### Agent Model Used

{To be populated by dev agent}

### Debug Log References

{To be populated by dev agent}

### Completion Notes List

{To be populated by dev agent}

### File List

{To be populated by dev agent}

## QA Results

{To be populated by QA agent}
