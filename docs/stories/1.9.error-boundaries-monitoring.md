# Story 1.9: React Error Boundaries & Monitoring

## Status

Draft

## Story

**As a** development team,
**I want** error boundaries and monitoring configured,
**so that** production errors are caught, logged, and don't break the entire application.

## Acceptance Criteria

1. React error boundary component created (`components/ErrorBoundary.tsx`) with fallback UI
2. Error boundary wraps entire app in `app/layout.tsx`
3. Sentry SDK installed and configured for production environment
4. Sentry DSN added to environment variables (.env.production)
5. Source maps uploaded to Sentry during build process
6. Uncaught errors logged to Sentry with user context (user ID, role)
7. Firebase operation errors logged with operation type and error details
8. Error fallback UI shows user-friendly message with "Try again" button
9. Error boundary resets state when user clicks "Try again"
10. Dev environment shows detailed error stack, prod environment shows friendly message

## Tasks / Subtasks

- [ ] Create React Error Boundary component (AC: 1, 8, 9)
  - [ ] Create components/ErrorBoundary.tsx with class component
  - [ ] Implement getDerivedStateFromError lifecycle method
  - [ ] Implement componentDidCatch lifecycle method
  - [ ] Create fallback UI with user-friendly error message
  - [ ] Add "Try again" button to reset error state
- [ ] Integrate Error Boundary in app layout (AC: 2)
  - [ ] Wrap app content in ErrorBoundary in app/layout.tsx
  - [ ] Ensure boundary catches all child component errors
  - [ ] Verify boundary doesn't interfere with hot reload in dev
- [ ] Install and configure Sentry SDK (AC: 3, 4)
  - [ ] Install @sentry/nextjs package
  - [ ] Create sentry.client.config.ts for client-side
  - [ ] Create sentry.server.config.ts for server-side
  - [ ] Add NEXT_PUBLIC_SENTRY_DSN to .env.production
  - [ ] Configure Sentry.init() with DSN and environment
- [ ] Configure source maps upload (AC: 5)
  - [ ] Add sentry.properties file with auth token
  - [ ] Configure next.config.js with Sentry webpack plugin
  - [ ] Set productionBrowserSourceMaps: true in next.config.js
  - [ ] Test source maps in staging deployment
- [ ] Add user context to Sentry errors (AC: 6)
  - [ ] Set Sentry user context on authentication
  - [ ] Include user ID and role in error reports
  - [ ] Update context in Zustand auth store actions
- [ ] Add Firebase operation error logging (AC: 7)
  - [ ] Wrap Firestore operations in try/catch blocks
  - [ ] Log Firebase errors to Sentry with captureException
  - [ ] Include operation type (create, update, delete, query)
  - [ ] Include collection name and document ID in error context
- [ ] Implement environment-specific error display (AC: 10)
  - [ ] Show detailed error stack in development environment
  - [ ] Show user-friendly message in production environment
  - [ ] Use process.env.NODE_ENV to determine environment
  - [ ] Test both dev and prod error displays

## Dev Notes

### Error Boundary Pattern

[Source: architecture.md#Architectural Patterns - Error Boundary Pattern]

**Implementation (components/ErrorBoundary.tsx):**

```typescript
'use client';

import React, { Component, ReactNode } from 'react';
import * as Sentry from '@sentry/nextjs';
import { Button } from '@/components/ui/button';
import { Card, CardHeader, CardTitle, CardDescription, CardFooter } from '@/components/ui/card';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // Log to Sentry in production
    if (process.env.NODE_ENV === 'production') {
      Sentry.captureException(error, {
        contexts: {
          react: {
            componentStack: errorInfo.componentStack,
          },
        },
      });
    } else {
      // Log to console in development
      console.error('Error caught by boundary:', error, errorInfo);
    }
  }

  handleReset = () => {
    this.setState({ hasError: false, error: null });
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className="flex items-center justify-center min-h-screen bg-background">
          <Card className="w-full max-w-md">
            <CardHeader>
              <CardTitle>Something went wrong</CardTitle>
              <CardDescription>
                {process.env.NODE_ENV === 'production'
                  ? 'We apologize for the inconvenience. Please try again.'
                  : this.state.error?.message || 'An unexpected error occurred'}
              </CardDescription>
            </CardHeader>
            <CardFooter>
              <Button onClick={this.handleReset} className="w-full">
                Try Again
              </Button>
            </CardFooter>
          </Card>
        </div>
      );
    }

    return this.props.children;
  }
}
```

**Key Points:**

- Use class component (required for error boundary lifecycle methods)
- getDerivedStateFromError: Update state to render fallback UI
- componentDidCatch: Log error to Sentry (production) or console (dev)
- Reset functionality: Clear error state and re-render children

### Sentry Configuration

[Source: architecture.md#Tech Stack - Monitoring/Logging]

**Installation:**

```bash
npm install @sentry/nextjs
npx @sentry/wizard@latest -i nextjs
```

**Client Configuration (sentry.client.config.ts):**

```typescript
import * as Sentry from '@sentry/nextjs'

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0,
  debug: false,
  replaysOnErrorSampleRate: 1.0,
  replaysSessionSampleRate: 0.1,
  integrations: [
    new Sentry.Replay({
      maskAllText: true,
      blockAllMedia: true,
    }),
  ],
})
```

**Server Configuration (sentry.server.config.ts):**

```typescript
import * as Sentry from '@sentry/nextjs'

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0,
  debug: false,
})
```

**Environment Variables (.env.production):**

```bash
NEXT_PUBLIC_SENTRY_DSN=https://your-sentry-dsn@sentry.io/project-id
SENTRY_AUTH_TOKEN=your-auth-token
SENTRY_ORG=your-org
SENTRY_PROJECT=salonflow
```

### Source Maps Upload

[Source: architecture.md#Tech Stack - Sentry]

**Next.js Configuration (next.config.js):**

```javascript
const { withSentryConfig } = require('@sentry/nextjs')

const nextConfig = {
  productionBrowserSourceMaps: true,
  // Other Next.js config...
}

const sentryWebpackPluginOptions = {
  silent: true,
  org: process.env.SENTRY_ORG,
  project: process.env.SENTRY_PROJECT,
  authToken: process.env.SENTRY_AUTH_TOKEN,
}

module.exports = withSentryConfig(nextConfig, sentryWebpackPluginOptions)
```

**Sentry Properties (sentry.properties):**

```
defaults.url=https://sentry.io/
defaults.org=your-org
defaults.project=salonflow
auth.token=your-auth-token
```

**Key Points:**

- Source maps uploaded automatically during build
- Maps are NOT deployed to production (only to Sentry)
- Enables readable stack traces in Sentry dashboard

### User Context Tracking

[Source: architecture.md#Coding Standards - Error Handling]

**Setting User Context (stores/authStore.ts):**

```typescript
import * as Sentry from '@sentry/nextjs'

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      setUser: (user) => {
        // Update Sentry user context
        if (user) {
          Sentry.setUser({
            id: user.id,
            username: user.username,
            role: user.role,
          })
        } else {
          Sentry.setUser(null)
        }

        set({ user, isAuthenticated: !!user, isLoading: false })
      },
      logout: () => {
        Sentry.setUser(null)
        set({ user: null, isAuthenticated: false })
      },
    }),
    { name: 'auth-storage' }
  )
)
```

**Key Points:**

- Set user context immediately after authentication
- Clear context on logout
- Include minimal PII (ID, username, role - no email/password)

### Firebase Error Logging

[Source: architecture.md#Error Handling Strategy]

**Error Handling Pattern:**

```typescript
// lib/services/service-management.ts
import * as Sentry from '@sentry/nextjs'
import { toast } from 'sonner'

export async function createService(data: CreateServiceDto) {
  try {
    const docRef = await addDoc(collection(db, 'services'), {
      ...data,
      createdAt: serverTimestamp(),
    })
    toast.success('Service created successfully')
    return docRef.id
  } catch (error) {
    console.error('Failed to create service:', error)

    // Log to Sentry with context
    Sentry.captureException(error, {
      tags: {
        operation: 'create',
        collection: 'services',
      },
      extra: {
        serviceData: data,
      },
    })

    // Show user-friendly error
    toast.error('Failed to create service. Please try again.')
    throw error
  }
}
```

**Error Context Tags:**

- operation: create, update, delete, query
- collection: users, services, serviceLogs
- documentId: (if applicable)
- userId: (from Sentry user context)
- role: (from Sentry user context)

### Environment-Specific Error Display

[Source: architecture.md#Coding Standards - Critical Rules]

**Development Environment:**

- Show full error message and stack trace
- Log detailed error info to console
- Display error details in ErrorBoundary fallback UI

**Production Environment:**

- Show user-friendly generic message
- Hide technical details from users
- Log all details to Sentry for debugging

**Environment Detection:**

```typescript
const isDevelopment = process.env.NODE_ENV === 'development'
const errorMessage = isDevelopment
  ? error.message
  : 'An unexpected error occurred. Our team has been notified.'
```

### Testing

[Source: architecture.md#Testing Strategy]

**Unit Tests (Vitest):**

- Location: `tests/unit/components/ErrorBoundary.test.tsx`
- Test ErrorBoundary catches and displays errors
- Test "Try Again" button resets error state
- Test componentDidCatch logs to Sentry (mock Sentry.captureException)
- Test dev vs prod error message display
- Test error boundary resets when children change

**Component Tests:**

- Test ErrorBoundary with component that throws error
- Verify fallback UI renders correctly
- Verify user context set on authentication

**E2E Tests (Playwright):**

- Location: `tests/e2e/error-handling.spec.ts`
- Test: "Error boundary catches component errors"
  - Trigger intentional error (e.g., bad API response)
  - Verify error boundary fallback displays
  - Click "Try Again" button
  - Verify app recovers
- Test: "Network errors display toast notification"
  - Simulate network failure
  - Verify toast error message displays
  - Verify app remains functional

**Manual Testing:**

- Deploy to staging with Sentry DSN
- Trigger intentional error
- Verify error appears in Sentry dashboard with:
  - User context (ID, role)
  - Source maps (readable stack trace)
  - Breadcrumbs (user actions before error)

**Example Test:**

```typescript
describe('ErrorBoundary', () => {
  it('catches errors and displays fallback UI', () => {
    const ThrowError = () => {
      throw new Error('Test error');
    };

    render(
      <ErrorBoundary>
        <ThrowError />
      </ErrorBoundary>
    );

    expect(screen.getByText('Something went wrong')).toBeInTheDocument();
    expect(screen.getByText('Try Again')).toBeInTheDocument();
  });

  it('logs error to Sentry in production', () => {
    const captureExceptionSpy = vi.spyOn(Sentry, 'captureException');
    process.env.NODE_ENV = 'production';

    const ThrowError = () => {
      throw new Error('Test error');
    };

    render(
      <ErrorBoundary>
        <ThrowError />
      </ErrorBoundary>
    );

    expect(captureExceptionSpy).toHaveBeenCalledWith(
      expect.any(Error),
      expect.objectContaining({
        contexts: expect.any(Object),
      })
    );
  });

  it('resets error state when "Try Again" clicked', () => {
    const ThrowError = ({ shouldThrow }: { shouldThrow: boolean }) => {
      if (shouldThrow) throw new Error('Test error');
      return <div>Success</div>;
    };

    const { rerender } = render(
      <ErrorBoundary>
        <ThrowError shouldThrow={true} />
      </ErrorBoundary>
    );

    expect(screen.getByText('Try Again')).toBeInTheDocument();

    fireEvent.click(screen.getByText('Try Again'));

    rerender(
      <ErrorBoundary>
        <ThrowError shouldThrow={false} />
      </ErrorBoundary>
    );

    expect(screen.getByText('Success')).toBeInTheDocument();
  });
});

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-10 | v1.0 | Initial story creation | PM Agent (John) |

## Dev Agent Record
### Agent Model Used
{To be populated by dev agent}

### Debug Log References
{To be populated by dev agent}

### Completion Notes List
{To be populated by dev agent}

### File List
{To be populated by dev agent}

## QA Results
{To be populated by QA agent}
```
