# Story 3.12: Optimistic UI Updates & Error Recovery

## Status

Draft

## Story

**As a** user,
**I want** instant feedback when I take actions, with graceful recovery if something fails,
**so that** the app feels fast and reliable even with network issues.

## Acceptance Criteria

1. React Query configured for optimistic updates on all mutations (log service, approve, reject)
2. When barber clicks "Log Service": Rows appear in table instantly (before Firestore confirms)
3. When manager clicks approve: Row disappears from pending queue instantly
4. If Firebase write fails: Optimistic update rolled back automatically
5. Error toast shown: "Action failed. Please try again."
6. Failed row animates "shake" effect (100ms) to indicate error
7. User can retry action immediately after failure
8. Network status monitored: If offline, show persistent toast: "You're offline. Changes will sync when reconnected."
9. When reconnected: Queued mutations automatically retry
10. E2E test verifies: Disconnect network mid-action, verify rollback and error message

## Tasks / Subtasks

- [ ] Configure React Query for optimistic updates (AC: 1)
  - [ ] Set up QueryClient with default options
  - [ ] Enable retry logic with exponential backoff
  - [ ] Configure mutation callbacks (onMutate, onError, onSuccess)
  - [ ] Add QueryClientProvider to app root
  - [ ] Install React Query DevTools for debugging
- [ ] Implement optimistic update for log service mutation (AC: 2, 4, 5)
  - [ ] In useMutation onMutate: add new logs to cache immediately
  - [ ] Cancel in-flight queries to prevent race conditions
  - [ ] Save previous state for rollback
  - [ ] On success: invalidate queries to fetch authoritative data
  - [ ] On error: restore previous state from snapshot
  - [ ] Show error toast with retry option
- [ ] Implement optimistic update for approve mutation (AC: 3, 4, 5)
  - [ ] In onMutate: remove log from pending queue cache
  - [ ] Add log to approved logs cache
  - [ ] On error: restore log to pending queue
  - [ ] Show error toast
- [ ] Implement optimistic update for reject mutation (AC: 4, 5)
  - [ ] In onMutate: remove log from pending queue cache
  - [ ] Add log to rejected logs cache
  - [ ] On error: restore log to pending queue
  - [ ] Show error toast
- [ ] Add shake animation for failed actions (AC: 6)
  - [ ] Create shake keyframe animation in CSS
  - [ ] Apply animation class to failed row on error
  - [ ] Remove animation class after 100ms
  - [ ] Test animation doesn't block retries
- [ ] Implement retry mechanism (AC: 7)
  - [ ] Add "Retry" button to error toast
  - [ ] Clicking retry re-invokes mutation with same parameters
  - [ ] Show loading state during retry
  - [ ] Limit retries to 3 attempts (prevent infinite loops)
- [ ] Add network status monitoring (AC: 8, 9)
  - [ ] Create useNetworkStatus hook
  - [ ] Listen to window online/offline events
  - [ ] Show persistent toast when offline
  - [ ] Hide toast when reconnected
  - [ ] Queue mutations when offline (React Query retry mechanism)
  - [ ] Auto-retry queued mutations on reconnection
- [ ] Write E2E test for network disconnect (AC: 10)
  - [ ] Use Playwright page.setOfflineMode(true)
  - [ ] Barber attempts to log service while offline
  - [ ] Verify optimistic update shows in UI
  - [ ] Verify error toast appears
  - [ ] Verify rollback occurs
  - [ ] Reconnect network
  - [ ] Verify queued mutation retries automatically

## Dev Notes

### React Query Configuration for Optimistic Updates

[Source: architecture.md#Architectural Patterns - Optimistic UI Updates]

React Query provides built-in support for optimistic updates with automatic rollback on error, making the UI feel instant while maintaining data consistency.

**QueryClient Setup:**

```typescript
// lib/react-query/client.ts
import { QueryClient } from '@tanstack/react-query'

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      gcTime: 10 * 60 * 1000, // 10 minutes
      retry: 3,
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000), // Exponential backoff
    },
    mutations: {
      retry: 3,
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
  },
})
```

**Provider Setup:**

```typescript
// app/layout.tsx
import { QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { queryClient } from '@/lib/react-query/client';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html>
      <body>
        <QueryClientProvider client={queryClient}>
          {children}
          <ReactQueryDevtools initialIsOpen={false} />
        </QueryClientProvider>
      </body>
    </html>
  );
}
```

### Optimistic Update Pattern - Log Service

[Source: architecture.md#Components - Approval Workflow Service]

```typescript
// hooks/useLogServices.ts
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { logServices } from '@/lib/services/service-logging'
import { toast } from 'sonner'
import type { ServiceLog } from '@/types/firestore'

export function useLogServices(barberId: string) {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (serviceIds: string[]) => logServices(barberId, serviceIds),

    // Optimistic update: Add new logs to cache before Firestore confirms
    onMutate: async (serviceIds) => {
      // Cancel outgoing queries to prevent race conditions
      await queryClient.cancelQueries({ queryKey: ['serviceLogs', barberId] })

      // Snapshot current state for rollback
      const previousLogs = queryClient.getQueryData<ServiceLog[]>([
        'serviceLogs',
        barberId,
      ])

      // Optimistically add new logs to cache
      const optimisticLogs = serviceIds.map((serviceId) => ({
        id: `temp-${Date.now()}-${serviceId}`, // Temporary ID
        barberId,
        serviceId,
        status: 'pending' as const,
        createdAt: new Date(),
        // Note: price, commissionRate, commissionAmount will be set by server
      }))

      queryClient.setQueryData<ServiceLog[]>(
        ['serviceLogs', barberId],
        (old) => [...(old ?? []), ...optimisticLogs]
      )

      return { previousLogs } // Context for rollback
    },

    // Rollback on error
    onError: (error, variables, context) => {
      if (context?.previousLogs) {
        queryClient.setQueryData(
          ['serviceLogs', barberId],
          context.previousLogs
        )
      }
      toast.error('Failed to log services. Please try again.', {
        action: {
          label: 'Retry',
          onClick: () => logServices(barberId, variables),
        },
      })
    },

    // Success: Invalidate to fetch authoritative data
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['serviceLogs', barberId] })
      toast.success(
        `${data.length} service(s) logged successfully. Pending manager approval.`
      )
    },
  })
}
```

### Optimistic Update Pattern - Approve Log

[Source: architecture.md#Components - Approval Workflow Service]

```typescript
// hooks/useApproveLog.ts
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { approveLog } from '@/lib/services/approval-workflow'
import { toast } from 'sonner'
import type { ServiceLog } from '@/types/firestore'

export function useApproveLog() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: approveLog,

    onMutate: async (logId: string) => {
      // Cancel pending queries
      await queryClient.cancelQueries({ queryKey: ['serviceLogs', 'pending'] })

      // Snapshot for rollback
      const previousLogs = queryClient.getQueryData<ServiceLog[]>([
        'serviceLogs',
        'pending',
      ])

      // Optimistically remove from pending queue
      queryClient.setQueryData<ServiceLog[]>(
        ['serviceLogs', 'pending'],
        (old) => old?.filter((log) => log.id !== logId) ?? []
      )

      return { previousLogs }
    },

    onError: (error, logId, context) => {
      // Rollback
      if (context?.previousLogs) {
        queryClient.setQueryData(
          ['serviceLogs', 'pending'],
          context.previousLogs
        )
      }

      // Shake animation on failed row
      const rowElement = document.querySelector(`[data-log-id="${logId}"]`)
      if (rowElement) {
        rowElement.classList.add('animate-shake')
        setTimeout(() => rowElement.classList.remove('animate-shake'), 100)
      }

      toast.error('Action failed. Please try again.')
    },

    onSuccess: () => {
      // Invalidate all service log queries to refetch
      queryClient.invalidateQueries({ queryKey: ['serviceLogs'] })
      toast.success('Service log approved')
    },
  })
}
```

### Shake Animation

[Source: architecture.md#Architectural Patterns - Optimistic UI Updates]

```css
/* app/globals.css */
@keyframes shake {
  0%,
  100% {
    transform: translateX(0);
  }
  25% {
    transform: translateX(-5px);
  }
  75% {
    transform: translateX(5px);
  }
}

.animate-shake {
  animation: shake 0.1s ease-in-out;
}
```

**Usage in Component:**

```typescript
<tr data-log-id={log.id} className="transition-all">
  {/* Table cells */}
</tr>
```

### Network Status Monitoring

[Source: architecture.md#Error Handling Strategy]

```typescript
// hooks/useNetworkStatus.ts
import { useEffect, useState } from 'react'
import { toast } from 'sonner'

export function useNetworkStatus() {
  const [isOnline, setIsOnline] = useState(
    typeof navigator !== 'undefined' ? navigator.onLine : true
  )

  useEffect(() => {
    let offlineToastId: string | number

    const handleOnline = () => {
      setIsOnline(true)
      if (offlineToastId) {
        toast.dismiss(offlineToastId)
      }
      toast.success("You're back online. Changes will sync now.")
    }

    const handleOffline = () => {
      setIsOnline(false)
      offlineToastId = toast.error(
        "You're offline. Changes will sync when reconnected.",
        { duration: Infinity } // Persistent toast
      )
    }

    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)

    return () => {
      window.removeEventListener('online', handleOnline)
      window.removeEventListener('offline', handleOffline)
    }
  }, [])

  return isOnline
}
```

**Usage in App Root:**

```typescript
// app/layout.tsx
import { useNetworkStatus } from '@/hooks/useNetworkStatus';

export default function RootLayout({ children }) {
  useNetworkStatus(); // Monitors network status globally

  return <>{children}</>;
}
```

### React Query Automatic Retry on Reconnection

[Source: architecture.md#Architectural Patterns - Optimistic UI Updates]

React Query automatically retries failed mutations when the network reconnects. No additional code needed.

**How It Works:**

1. User goes offline
2. Mutation fails (Firestore network error)
3. React Query queues mutation with retry logic
4. User comes back online
5. React Query detects reconnection via `window.addEventListener('online')`
6. Queued mutations automatically retry with exponential backoff

**Configuration:**

```typescript
mutations: {
  retry: 3, // Retry up to 3 times
  retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  networkMode: 'offlineFirst', // Queue mutations when offline
}
```

### Error Handling with Retry Button

[Source: architecture.md#Error Handling Strategy - Frontend Error Handling]

```typescript
import { toast } from 'sonner'
import { handleError } from '@/lib/utils/error-handler'

export function handleMutationError(error: unknown, retryFn: () => void) {
  console.error('Mutation failed:', error)

  toast.error('Action failed. Please try again.', {
    duration: 6000,
    action: {
      label: 'Retry',
      onClick: retryFn,
    },
  })

  // Log to Sentry in production
  if (process.env.NODE_ENV === 'production') {
    Sentry.captureException(error)
  }
}
```

### Offline Detection and Queue Management

[Source: architecture.md#Error Handling Strategy]

```typescript
// lib/utils/network.ts
export function isOfflineError(error: unknown): boolean {
  if (error instanceof Error) {
    return (
      error.message.includes('offline') ||
      error.message.includes('network') ||
      error.message.includes('Failed to fetch')
    )
  }
  return false
}

export function shouldRetry(error: unknown, attemptNumber: number): boolean {
  // Don't retry non-network errors
  if (!isOfflineError(error)) return false

  // Retry up to 3 times
  return attemptNumber < 3
}
```

### Testing

**Unit Tests Required:**
[Source: architecture.md#Testing Strategy - Frontend Unit Tests]

1. **Optimistic Update Test** (`tests/unit/hooks/useLogServices.test.ts`)
   - Mock Firestore SDK
   - Call mutation
   - Verify cache updated immediately (before Firestore confirms)
   - Simulate Firestore success
   - Verify cache invalidated and refetched
   - Simulate Firestore error
   - Verify cache rolled back to previous state

2. **Network Status Hook Test** (`tests/unit/hooks/useNetworkStatus.test.ts`)
   - Mock navigator.onLine
   - Trigger offline event
   - Verify isOnline = false
   - Verify offline toast shown
   - Trigger online event
   - Verify isOnline = true
   - Verify online toast shown, offline toast dismissed

**E2E Tests Required:**
[Source: architecture.md#Testing Strategy - E2E Tests]

3. **Optimistic UI Test** (`tests/e2e/optimistic-updates.spec.ts`)
   - Barber logs a service
   - Verify row appears in table immediately (before network request completes)
   - Wait for network request to complete
   - Verify row persists with correct data

4. **Error Rollback Test** (`tests/e2e/error-rollback.spec.ts`)
   - Mock Firestore to return error on next write
   - Barber attempts to log service
   - Verify row appears optimistically
   - Verify error occurs
   - Verify row disappears (rollback)
   - Verify error toast shown
   - Click "Retry" button
   - Verify retry succeeds

5. **Network Disconnect Test** (`tests/e2e/network-disconnect.spec.ts`)
   - Barber logs in
   - Use Playwright: `await page.context().setOffline(true)`
   - Barber attempts to log service
   - Verify offline toast appears: "You're offline..."
   - Verify optimistic update shows in UI
   - Wait for error
   - Verify rollback occurs
   - Reconnect: `await page.context().setOffline(false)`
   - Verify online toast appears
   - Verify queued mutation retries automatically
   - Verify service log persists after reconnection

6. **Shake Animation Test** (`tests/e2e/shake-animation.spec.ts`)
   - Mock approval mutation to fail
   - Manager clicks approve
   - Verify shake animation plays on row
   - Verify animation lasts ~100ms
   - Verify row remains clickable after animation

**Example E2E Test:**

```typescript
// tests/e2e/network-disconnect.spec.ts
import { test, expect } from '@playwright/test'

test('handles network disconnect gracefully', async ({ page }) => {
  // Login as barber
  await page.goto('http://localhost:3000/login')
  await page.click('text=Barber')
  await page.click('text=John Barber')

  // Go offline
  await page.context().setOffline(true)

  // Attempt to log service
  await page.click('text=Haircut')
  await page.click('button:has-text("Log 1 Service")')

  // Verify offline toast
  await expect(page.locator("text=You're offline")).toBeVisible()

  // Verify optimistic update (row appears)
  await expect(page.locator('table tbody tr:has-text("Pending")')).toBeVisible()

  // Wait for error and rollback
  await expect(
    page.locator('table tbody tr:has-text("Pending")')
  ).not.toBeVisible({ timeout: 5000 })

  // Go back online
  await page.context().setOffline(false)

  // Verify reconnection toast
  await expect(page.locator("text=You're back online")).toBeVisible()

  // Retry should happen automatically (React Query retry mechanism)
  // Verify service log appears after retry
  await expect(page.locator('table tbody tr:has-text("Pending")')).toBeVisible({
    timeout: 5000,
  })
})
```

**Performance Test:** 7. **Rapid Actions Test** (`tests/e2e/rapid-actions.spec.ts`)

- Manager approves 10 logs in rapid succession (< 1s between clicks)
- Verify all optimistic updates occur instantly
- Verify no race conditions or lost updates
- Verify final state matches expected state after all updates complete

## Change Log

| Date       | Version | Description            | Author          |
| ---------- | ------- | ---------------------- | --------------- |
| 2025-10-10 | v1.0    | Initial story creation | PM Agent (John) |

## Dev Agent Record

### Agent Model Used

{To be populated by dev agent}

### Debug Log References

{To be populated by dev agent}

### Completion Notes List

{To be populated by dev agent}

### File List

{To be populated by dev agent}

## QA Results

{To be populated by QA agent}
