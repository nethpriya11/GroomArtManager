# Story 4.5: Detailed Financial Ledger

## Status

Draft

## Story

**As a** manager,
**I want** a complete transaction-level report of all approved services,
**so that** I can audit commissions and verify payroll.

## Acceptance Criteria

1. Reports page includes "Financial Ledger" section below leaderboards
2. Full-width table with columns: Date, Barber, Service, Price, Commission Rate, Commission Amount, Net Profit (Price - Commission)
3. Displays all approved service logs within selected date range
4. Sorted by date descending (newest first)
5. Pagination: 50 rows per page (ShadCN Pagination component)
6. Real-time updates: New approved logs appear at top of table
7. Mobile responsive: Table scrolls horizontally or columns stack
8. Export button (stretch goal - not required for MVP)
9. Totals row at bottom of each page: Sum of Price, Commission Amount, Net Profit columns
10. Empty state: "No transactions in selected date range"

## Tasks / Subtasks

- [ ] Create financial ledger query function (AC: 2, 3, 4)
  - [ ] Implement `getFinancialLedger(dateRange, pagination)` in `lib/services/reporting-service.ts`
  - [ ] Query serviceLogs where status='approved' within date range
  - [ ] Order by createdAt descending (newest first)
  - [ ] Implement cursor-based pagination with limit of 50 rows per page
  - [ ] Join with users and services collections to get names
  - [ ] Return ledger entries with all required fields: date, barber name, service name, price, commissionRate, commissionAmount, netProfit
- [ ] Create custom hook for real-time ledger (AC: 6)
  - [ ] Implement `useFinancialLedger(dateRange, page)` in `hooks/useFinancialLedger.ts`
  - [ ] Wrap query with React Query and onSnapshot listener
  - [ ] Handle pagination state and cursor management
  - [ ] Re-query when date range or page changes
  - [ ] Ensure new approved logs appear at top of table in real-time
  - [ ] Configure staleTime: Infinity for real-time data
- [ ] Build financial ledger table component (AC: 1, 2, 7)
  - [ ] Create `FinancialLedgerTable.tsx` in `components/reports/`
  - [ ] Define table columns: Date, Barber, Service, Price, Commission Rate, Commission Amount, Net Profit
  - [ ] Use ShadCN Table component for styling
  - [ ] Format date as MM/DD/YYYY HH:mm
  - [ ] Format currency values ($XXX.XX)
  - [ ] Format commission rate as percentage (45%)
  - [ ] Calculate net profit: Price - Commission Amount
  - [ ] Full-width layout (spans entire page width)
- [ ] Implement pagination (AC: 5)
  - [ ] Add ShadCN Pagination component below table
  - [ ] Show 50 rows per page
  - [ ] Display current page and total pages
  - [ ] Previous/Next buttons for navigation
  - [ ] Use cursor-based pagination for Firestore efficiency
  - [ ] Disable Previous on page 1, Next on last page
- [ ] Implement totals row (AC: 9)
  - [ ] Calculate totals for current page: sum of Price, Commission Amount, Net Profit
  - [ ] Display totals row at bottom of table
  - [ ] Bold font for totals row
  - [ ] Update totals when page changes
- [ ] Implement responsive table (AC: 7)
  - [ ] Desktop: Full table with all columns
  - [ ] Tablet (<1024px): Horizontal scroll with all columns
  - [ ] Mobile (<768px): Consider stacking columns or horizontal scroll
  - [ ] Use Tailwind `overflow-x-auto` for horizontal scroll
  - [ ] Test on various screen sizes
- [ ] Integrate ledger into reports page (AC: 1)
  - [ ] Add FinancialLedgerTable below leaderboards in `app/manager/reports/page.tsx`
  - [ ] Full-width section spanning entire page
  - [ ] Add section heading: "Financial Ledger"
  - [ ] Pass selected date range to ledger component
- [ ] Handle empty state (AC: 10)
  - [ ] Display "No transactions in selected date range" when no data
  - [ ] Show empty state component (not error)
  - [ ] Maintain table structure with empty message
- [ ] Implement loading state (AC: 4, 6)
  - [ ] Create skeleton loader for table rows
  - [ ] Show 50 skeleton rows while data loading
  - [ ] Use ShadCN Skeleton component
- [ ] Test real-time updates (AC: 6)
  - [ ] Approve service log, verify appears at top of ledger within 2s
  - [ ] Verify ledger updates while on page 1
  - [ ] Test pagination doesn't break with real-time updates
- [ ] Implement export functionality (AC: 8)
  - [ ] Add "Export" button above table (stretch goal)
  - [ ] Export to CSV format with all columns
  - [ ] Include all pages, not just current page
  - [ ] Document as future enhancement if not implemented
- [ ] Test pagination with large dataset (AC: 5)
  - [ ] Seed Firestore with 100+ service logs
  - [ ] Verify pagination works correctly
  - [ ] Test navigation between pages
  - [ ] Verify cursor-based pagination efficiency

## Dev Notes

### Financial Ledger Query Function

[Source: architecture.md#Reporting & Analytics Service]

The `getFinancialLedger()` function queries service logs and joins with barber/service details:

**Implementation Pattern:**

```typescript
export async function getFinancialLedger(
  dateRange: DateRange,
  pagination: { page: number; pageSize: number; lastDoc?: DocumentSnapshot }
): Promise<{
  entries: LedgerEntry[]
  hasMore: boolean
  lastDoc: DocumentSnapshot | null
}> {
  const db = getFirestore()

  // Query approved logs within date range, paginated
  let logsQuery = query(
    collection(db, 'serviceLogs'),
    where('status', '==', 'approved'),
    where('createdAt', '>=', Timestamp.fromDate(dateRange.from)),
    where('createdAt', '<=', Timestamp.fromDate(dateRange.to)),
    orderBy('createdAt', 'desc'),
    limit(pagination.pageSize)
  )

  // Apply cursor for pagination
  if (pagination.lastDoc) {
    logsQuery = query(logsQuery, startAfter(pagination.lastDoc))
  }

  const snapshot = await getDocs(logsQuery)

  // Fetch barber and service details for each log
  const entries = await Promise.all(
    snapshot.docs.map(async (doc) => {
      const log = doc.data() as ServiceLog

      // Fetch barber details
      const barberDoc = await getDoc(doc(db, 'users', log.barberId))
      const barber = barberDoc.data() as UserProfile

      // Fetch service details
      const serviceDoc = await getDoc(doc(db, 'services', log.serviceId))
      const service = serviceDoc.data() as Service

      return {
        id: doc.id,
        date: log.createdAt.toDate(),
        barberName: barber.username,
        serviceName: service.name,
        price: log.price,
        commissionRate: log.commissionRate,
        commissionAmount: log.commissionAmount,
        netProfit: log.price - log.commissionAmount,
      }
    })
  )

  return {
    entries,
    hasMore: snapshot.docs.length === pagination.pageSize,
    lastDoc: snapshot.docs[snapshot.docs.length - 1] || null,
  }
}
```

### Cursor-based Pagination

[Source: architecture.md#Database Schema]

Use Firestore cursor-based pagination for efficiency:

- Store last document snapshot from current page
- Use `startAfter(lastDoc)` to fetch next page
- More efficient than offset-based pagination for large datasets
- Prevents skipping documents when data changes in real-time

**React Query Integration:**

```typescript
export function useFinancialLedger(dateRange: DateRange, page: number) {
  const [cursors, setCursors] = useState<Map<number, DocumentSnapshot>>(
    new Map()
  )

  return useQuery({
    queryKey: ['financial-ledger', dateRange.from, dateRange.to, page],
    queryFn: async () => {
      const lastDoc = cursors.get(page - 1)
      const result = await getFinancialLedger(dateRange, {
        page,
        pageSize: 50,
        lastDoc,
      })

      // Store cursor for next page
      if (result.lastDoc) {
        setCursors((prev) => new Map(prev).set(page, result.lastDoc))
      }

      return result
    },
  })
}
```

### Real-time Updates with Pagination

[Source: architecture.md#Real-time Sync Engine]

**Challenge:** Real-time updates with pagination can cause issues (new items insert at top, shifting pages)

**Solution:**

1. Real-time updates only apply to page 1 (most recent transactions)
2. Pages 2+ use cached data until manually refreshed
3. Show "New transactions available" banner when on page 2+ and updates detected
4. User can click to return to page 1 and see latest data

**Implementation:**

```typescript
export function useFinancialLedger(dateRange: DateRange, page: number) {
  const isFirstPage = page === 1

  return useQuery({
    queryKey: ['financial-ledger', dateRange.from, dateRange.to, page],
    queryFn: () =>
      new Promise((resolve) => {
        if (isFirstPage) {
          // Real-time listener for page 1 only
          const logsQuery = query(
            collection(db, 'serviceLogs'),
            where('status', '==', 'approved'),
            where('createdAt', '>=', Timestamp.fromDate(dateRange.from)),
            where('createdAt', '<=', Timestamp.fromDate(dateRange.to)),
            orderBy('createdAt', 'desc'),
            limit(50)
          )

          const unsubscribe = onSnapshot(logsQuery, async (snapshot) => {
            const entries = await transformSnapshotToLedgerEntries(snapshot)
            resolve({ entries, hasMore: snapshot.docs.length === 50 })
          })

          return () => unsubscribe()
        } else {
          // Static query for pages 2+
          const result = await getFinancialLedger(dateRange, {
            page,
            pageSize: 50,
          })
          resolve(result)
        }
      }),
    staleTime: isFirstPage ? Infinity : 5 * 60 * 1000, // 5 min cache for pages 2+
  })
}
```

### Data Models

[Source: architecture.md#Data Models]

**ServiceLog:**

- `price`: number - Snapshot of service price at logging time
- `commissionRate`: number - Snapshot of barber's commission rate (0.0 - 1.0)
- `commissionAmount`: number - Calculated commission (price Ã— commissionRate)
- `status`: 'pending' | 'approved' | 'rejected'
- `createdAt`: Firestore Timestamp
- `barberId`: string - References user ID
- `serviceId`: string - References service ID

**Calculated Field:**

- `netProfit`: price - commissionAmount (calculate in component, not stored in DB)

### Table Column Specifications

| Column            | Data Type  | Format           | Alignment | Width |
| ----------------- | ---------- | ---------------- | --------- | ----- |
| Date              | Timestamp  | MM/DD/YYYY HH:mm | Left      | 150px |
| Barber            | String     | Plain text       | Left      | 150px |
| Service           | String     | Plain text       | Left      | 150px |
| Price             | Number     | $XXX.XX          | Right     | 100px |
| Commission Rate   | Number     | XX%              | Right     | 120px |
| Commission Amount | Number     | $XXX.XX          | Right     | 150px |
| Net Profit        | Calculated | $XXX.XX          | Right     | 120px |

### Totals Row Calculation

Calculate totals for current page only (not all pages):

```typescript
const pageTotals = {
  totalPrice: entries.reduce((sum, entry) => sum + entry.price, 0),
  totalCommission: entries.reduce(
    (sum, entry) => sum + entry.commissionAmount,
    0
  ),
  totalNetProfit: entries.reduce((sum, entry) => sum + entry.netProfit, 0),
}
```

### Firestore Composite Index Required

[Source: architecture.md#Database Schema]

Date-filtered approved logs with ordering:

```json
{
  "collectionGroup": "serviceLogs",
  "fields": [
    { "fieldPath": "status", "order": "ASCENDING" },
    { "fieldPath": "createdAt", "order": "DESCENDING" }
  ]
}
```

### Testing

[Source: architecture.md#Testing Strategy]

#### Component Tests

**Location:** `tests/component/reports/FinancialLedgerTable.test.tsx`

Test cases:

1. Renders table with all columns
2. Formats date correctly (MM/DD/YYYY HH:mm)
3. Formats currency values ($XXX.XX)
4. Formats commission rate as percentage (45%)
5. Calculates net profit correctly (price - commission)
6. Displays pagination controls
7. Shows 50 rows per page
8. Displays totals row at bottom
9. Totals calculated correctly for page
10. Displays empty state when no data
11. Shows loading skeleton while fetching

**Example:**

```typescript
describe('FinancialLedgerTable', () => {
  it('displays ledger entries with correct formatting', () => {
    const mockData = [
      {
        id: '1',
        date: new Date('2025-10-10T14:30:00'),
        barberName: 'John',
        serviceName: 'Haircut',
        price: 25,
        commissionRate: 0.45,
        commissionAmount: 11.25,
        netProfit: 13.75,
      },
    ];

    render(<FinancialLedgerTable entries={mockData} />);

    // Verify date formatting
    expect(screen.getByText('10/10/2025 14:30')).toBeInTheDocument();

    // Verify currency formatting
    expect(screen.getByText('$25.00')).toBeInTheDocument();
    expect(screen.getByText('$11.25')).toBeInTheDocument();
    expect(screen.getByText('$13.75')).toBeInTheDocument();

    // Verify percentage formatting
    expect(screen.getByText('45%')).toBeInTheDocument();
  });

  it('calculates and displays page totals', () => {
    const mockData = [
      { price: 25, commissionAmount: 11.25, netProfit: 13.75 },
      { price: 30, commissionAmount: 13.5, netProfit: 16.5 },
    ];

    render(<FinancialLedgerTable entries={mockData} />);

    // Verify totals row
    expect(screen.getByText('$55.00')).toBeInTheDocument(); // Total price
    expect(screen.getByText('$24.75')).toBeInTheDocument(); // Total commission
    expect(screen.getByText('$30.25')).toBeInTheDocument(); // Total net profit
  });
});
```

#### Pagination Tests

**Location:** `tests/component/reports/FinancialLedgerTable.test.tsx`

Test cases:

1. Displays page 1 by default
2. Next button fetches page 2
3. Previous button returns to page 1
4. Previous button disabled on page 1
5. Next button disabled on last page
6. Page number displays correctly
7. Cursor-based pagination works efficiently

#### Integration Tests

**Location:** `tests/component/reports/ReportsPage.test.tsx`

Test cases:

1. Ledger updates when date range changes
2. Ledger syncs with KPIs and leaderboards (same data)
3. Pagination persists when date range changes
4. Real-time updates appear on page 1

#### E2E Tests

**Location:** `tests/e2e/reports.spec.ts`

Test cases:

1. Manager views reports page with financial ledger
2. Verify 50 rows displayed on page 1
3. Click Next, verify page 2 loads
4. Click Previous, verify returns to page 1
5. Approve service log, verify appears at top of ledger (page 1)
6. Change date range, verify ledger updates
7. Test horizontal scroll on mobile devices
8. Verify totals row calculates correctly

**Test Flow:**

```typescript
test('Financial ledger shows paginated transactions', async ({ page }) => {
  // Seed database with 75 service logs
  await seedServiceLogs(75)

  await page.goto('/manager/reports')

  // Scroll to ledger section
  await page
    .locator('[data-testid="financial-ledger"]')
    .scrollIntoViewIfNeeded()

  // Verify 50 rows on page 1
  const rows = await page.locator('[data-testid="ledger-row"]').count()
  expect(rows).toBe(50)

  // Verify pagination shows "Page 1 of 2"
  await expect(page.locator('[data-testid="pagination-info"]')).toHaveText(
    'Page 1 of 2'
  )

  // Click Next
  await page.click('[data-testid="pagination-next"]')

  // Verify page 2 loads with remaining 25 rows
  await expect(page.locator('[data-testid="pagination-info"]')).toHaveText(
    'Page 2 of 2'
  )
  const page2Rows = await page.locator('[data-testid="ledger-row"]').count()
  expect(page2Rows).toBe(25)

  // Verify Next button disabled on last page
  await expect(page.locator('[data-testid="pagination-next"]')).toBeDisabled()
})

test('Financial ledger shows real-time updates on page 1', async ({
  page,
  context,
}) => {
  await page.goto('/manager/reports')

  // Record initial row count
  const initialCount = await page.locator('[data-testid="ledger-row"]').count()

  // Approve service log in second browser
  const page2 = await context.newPage()
  await page2.goto('/manager/approvals')
  await page2.click('[data-testid="approve-log-btn"]')

  // Verify new row appears at top of ledger within 2s
  await expect(page.locator('[data-testid="ledger-row"]')).toHaveCount(
    initialCount + 1,
    { timeout: 2000 }
  )

  // Verify new entry is at top (most recent)
  const firstRowDate = await page
    .locator('[data-testid="ledger-row"]')
    .first()
    .locator('[data-testid="entry-date"]')
    .textContent()
  // Should be current date/time
})

test('Financial ledger responsive on mobile', async ({ page }) => {
  await page.setViewportSize({ width: 375, height: 667 })
  await page.goto('/manager/reports')

  // Scroll to ledger
  await page
    .locator('[data-testid="financial-ledger"]')
    .scrollIntoViewIfNeeded()

  // Verify table scrolls horizontally
  const table = page.locator('[data-testid="ledger-table"]')
  await expect(table).toHaveCSS('overflow-x', 'auto')
})
```

#### Unit Tests

**Location:** `tests/unit/services/reporting-service.test.ts`

Test cases:

1. `getFinancialLedger()` returns paginated results (50 per page)
2. Filters only approved logs within date range
3. Orders by createdAt descending (newest first)
4. Joins with users and services collections correctly
5. Calculates net profit correctly (price - commission)
6. Handles pagination cursor correctly
7. Returns hasMore flag correctly
8. Returns empty array when no logs in range

**Example:**

```typescript
describe('getFinancialLedger', () => {
  it('returns paginated ledger entries', async () => {
    // Mock 75 service logs
    const mockLogs = Array.from({ length: 75 }, (_, i) => ({
      data: () => ({
        barberId: 'barber1',
        serviceId: 'service1',
        price: 25,
        commissionRate: 0.45,
        commissionAmount: 11.25,
        status: 'approved',
        createdAt: Timestamp.now(),
      }),
    }))

    mockGetDocs.mockResolvedValue({ docs: mockLogs.slice(0, 50) })

    const dateRange = { from: subDays(new Date(), 30), to: new Date() }
    const result = await getFinancialLedger(dateRange, {
      page: 1,
      pageSize: 50,
    })

    expect(result.entries).toHaveLength(50)
    expect(result.hasMore).toBe(true)
    expect(result.lastDoc).toBeDefined()
  })
})
```

## Change Log

| Date       | Version | Description            | Author          |
| ---------- | ------- | ---------------------- | --------------- |
| 2025-10-10 | v1.0    | Initial story creation | PM Agent (John) |

## Dev Agent Record

### Agent Model Used

{To be populated by dev agent}

### Debug Log References

{To be populated by dev agent}

### Completion Notes List

{To be populated by dev agent}

### File List

{To be populated by dev agent}

## QA Results

{To be populated by QA agent}
