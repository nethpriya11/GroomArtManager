# Story 4.7: Ledger Search Functionality

## Status

Draft

## Story

**As a** manager,
**I want** to search the financial ledger by barber or service name,
**so that** I can quickly find specific transactions.

## Acceptance Criteria

1. Search input field above financial ledger table
2. Placeholder text: "Search by barber or service name..."
3. Search debounced by 300ms (waits for user to stop typing)
4. Case-insensitive substring matching: Matches barber username or service name
5. Table filters to show only matching rows
6. Search applies on top of date range filter (both filters combine)
7. If no matches: Shows "No results found for '[query]'"
8. Clear search button (X icon) in input field
9. Search value persists in URL query param (?q=haircut)
10. Real-time: New logs that match search appear instantly

## Tasks / Subtasks

- [ ] Create search input component (AC: 1, 2, 8)
  - [ ] Add ShadCN Input component above financial ledger table
  - [ ] Set placeholder text: "Search by barber or service name..."
  - [ ] Add clear button (X icon) using ShadCN Button with icon
  - [ ] Style with dark theme (#1a1a1a background, #f59e0b focus ring)
- [ ] Implement debounced search (AC: 3)
  - [ ] Use custom hook: useDebounce(value, 300ms delay)
  - [ ] Only trigger search after user stops typing for 300ms
  - [ ] Show loading indicator during debounce period
- [ ] Implement case-insensitive substring matching (AC: 4, 5)
  - [ ] Filter service logs client-side: barber.username.toLowerCase().includes(query.toLowerCase())
  - [ ] Also match service.name.toLowerCase().includes(query.toLowerCase())
  - [ ] Update table to display only matching rows
- [ ] Combine search with date range filter (AC: 6)
  - [ ] Apply search filter on top of existing date range filtered data
  - [ ] Both filters must pass for row to display
  - [ ] Ensure filter order doesn't affect performance
- [ ] Handle empty search results (AC: 7)
  - [ ] Show empty state: "No results found for '[query]'"
  - [ ] Display search term in empty state message
  - [ ] Provide option to clear search
- [ ] Persist search in URL query params (AC: 9)
  - [ ] Store search value in URL: ?q=haircut
  - [ ] Parse query param on page load to restore search
  - [ ] Update URL when search changes using Next.js shallow routing
- [ ] Real-time search updates (AC: 10)
  - [ ] New logs that match search query appear instantly
  - [ ] Use existing Firestore real-time listeners
  - [ ] Apply search filter to new incoming data

## Dev Notes

### Search Input Component

[Source: architecture.md#Components - ShadCN UI]

**Component Structure:**

```
components/
├── ui/
│   └── input.tsx              # ShadCN Input component
└── features/
    └── reports/
        └── LedgerSearch.tsx   # Search input with debounce and clear button
```

**Implementation Pattern:**

```typescript
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { X } from 'lucide-react';

function LedgerSearch({ value, onChange, onClear }) {
  return (
    <div className="relative">
      <Input
        type="text"
        placeholder="Search by barber or service name..."
        value={value}
        onChange={(e) => onChange(e.target.value)}
        className="pr-10"
      />
      {value && (
        <Button
          variant="ghost"
          size="sm"
          className="absolute right-2 top-1/2 -translate-y-1/2"
          onClick={onClear}
          aria-label="Clear search"
        >
          <X className="h-4 w-4" />
        </Button>
      )}
    </div>
  );
}
```

### Debounced Search Hook

[Source: architecture.md#Hooks]

**Custom Hook:**

```typescript
// hooks/useDebounce.ts
import { useEffect, useState } from 'react'

function useDebounce<T>(value: T, delay: number = 300): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    return () => {
      clearTimeout(handler)
    }
  }, [value, delay])

  return debouncedValue
}

export default useDebounce
```

**Usage:**

```typescript
const [searchInput, setSearchInput] = useState('')
const debouncedSearch = useDebounce(searchInput, 300)

// Use debouncedSearch for filtering, not searchInput
const filteredLogs = logs.filter((log) => matchesSearch(log, debouncedSearch))
```

### Search Filtering Logic

[Source: architecture.md#Data Models - ServiceLog]

**Filter Implementation:**

```typescript
function matchesSearch(log: ServiceLog, query: string): boolean {
  if (!query.trim()) return true // Empty search matches all

  const normalizedQuery = query.toLowerCase().trim()

  // Get barber and service data (from joins/lookups)
  const barberName = log.barberName?.toLowerCase() || ''
  const serviceName = log.serviceName?.toLowerCase() || ''

  // Case-insensitive substring match
  return (
    barberName.includes(normalizedQuery) ||
    serviceName.includes(normalizedQuery)
  )
}

// Combined with date range filter
const filteredLogs = serviceLogs
  .filter((log) => isWithinDateRange(log, dateRange)) // Date filter first
  .filter((log) => matchesSearch(log, searchQuery)) // Then search filter
```

**Data Enrichment:**
Since ServiceLog only stores `barberId` and `serviceId`, you'll need to join with User and Service data:

```typescript
// Option 1: Client-side join (recommended for MVP)
const enrichedLogs = serviceLogs.map((log) => ({
  ...log,
  barberName: barbers.find((b) => b.id === log.barberId)?.username,
  serviceName: services.find((s) => s.id === log.serviceId)?.name,
}))

// Option 2: Firestore subcollection query (more complex)
// Would require denormalizing barber/service names into serviceLogs
```

### URL Query Parameter Management

[Source: architecture.md#Next.js App Router]

**Implementation:**

```typescript
import { useRouter, useSearchParams } from 'next/navigation'

function FinancialLedger() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const [searchQuery, setSearchQuery] = useState(searchParams.get('q') || '')

  const updateSearchParam = (query: string) => {
    const params = new URLSearchParams(searchParams)
    if (query) {
      params.set('q', query)
    } else {
      params.delete('q') // Remove param if search cleared
    }
    router.push(`?${params.toString()}`, { shallow: true })
  }

  // Update URL when debounced search changes
  useEffect(() => {
    updateSearchParam(debouncedSearch)
  }, [debouncedSearch])
}
```

**Query Param Format:**

- Use URL-encoded string: ?q=haircut
- For multi-word searches: ?q=john%20barber
- Combine with date range: ?from=2025-10-01&to=2025-10-31&q=haircut

### Performance Considerations

[Source: architecture.md#Performance Optimization]

**Client-Side Filtering:**

- Search is client-side (not Firestore query) because Firestore doesn't support full-text search
- For MVP with <1000 logs, client-side filtering is fast enough (<50ms)
- Filter runs on already date-filtered dataset (smaller subset)

**Future Optimization (if needed post-MVP):**

- Firestore doesn't support `contains` or regex queries
- For large datasets (10K+ logs), consider:
  - Algolia integration for full-text search
  - ElasticSearch for advanced search
  - Cloud Function to build search index

**Debounce Benefits:**

- Prevents re-filtering on every keystroke
- Reduces React re-renders
- Better UX (doesn't flicker while typing)

### Testing

#### Unit Tests

[Source: architecture.md#Testing Strategy - Frontend Unit Tests]

**Test File:** `tests/unit/hooks/useDebounce.test.ts`

**Test Cases:**

```typescript
import { renderHook, act } from '@testing-library/react'
import { useDebounce } from '@/hooks/useDebounce'

describe('useDebounce', () => {
  it('returns initial value immediately', () => {
    const { result } = renderHook(() => useDebounce('initial', 300))
    expect(result.current).toBe('initial')
  })

  it('debounces value changes by 300ms', async () => {
    vi.useFakeTimers()
    const { result, rerender } = renderHook(
      ({ value }) => useDebounce(value, 300),
      { initialProps: { value: 'initial' } }
    )

    // Update value
    rerender({ value: 'updated' })

    // Value should not change immediately
    expect(result.current).toBe('initial')

    // Fast-forward 299ms
    act(() => vi.advanceTimersByTime(299))
    expect(result.current).toBe('initial')

    // Fast-forward 1ms (total 300ms)
    act(() => vi.advanceTimersByTime(1))
    expect(result.current).toBe('updated')

    vi.useRealTimers()
  })

  it('cancels previous timeout on rapid changes', async () => {
    vi.useFakeTimers()
    const { result, rerender } = renderHook(
      ({ value }) => useDebounce(value, 300),
      { initialProps: { value: 'a' } }
    )

    rerender({ value: 'b' })
    act(() => vi.advanceTimersByTime(100))

    rerender({ value: 'c' })
    act(() => vi.advanceTimersByTime(100))

    rerender({ value: 'd' })
    act(() => vi.advanceTimersByTime(300))

    // Only final value should be set
    expect(result.current).toBe('d')

    vi.useRealTimers()
  })
})
```

**Test File:** `tests/unit/utils/search-helpers.test.ts`

**Test Cases:**

```typescript
describe('matchesSearch', () => {
  const mockLog = {
    id: 'log_1',
    barberId: 'barber_1',
    serviceId: 'service_1',
    barberName: 'John Barber',
    serviceName: 'Haircut',
    price: 25,
    status: 'approved',
  }

  it('matches barber name case-insensitively', () => {
    expect(matchesSearch(mockLog, 'john')).toBe(true)
    expect(matchesSearch(mockLog, 'JOHN')).toBe(true)
    expect(matchesSearch(mockLog, 'JoHn')).toBe(true)
  })

  it('matches service name case-insensitively', () => {
    expect(matchesSearch(mockLog, 'haircut')).toBe(true)
    expect(matchesSearch(mockLog, 'HAIRCUT')).toBe(true)
  })

  it('matches partial substrings', () => {
    expect(matchesSearch(mockLog, 'bar')).toBe(true) // matches "Barber"
    expect(matchesSearch(mockLog, 'cut')).toBe(true) // matches "Haircut"
  })

  it('returns false for non-matching queries', () => {
    expect(matchesSearch(mockLog, 'shave')).toBe(false)
    expect(matchesSearch(mockLog, 'xyz')).toBe(false)
  })

  it('returns true for empty query', () => {
    expect(matchesSearch(mockLog, '')).toBe(true)
    expect(matchesSearch(mockLog, '   ')).toBe(true)
  })

  it('trims whitespace from query', () => {
    expect(matchesSearch(mockLog, '  john  ')).toBe(true)
  })
})
```

#### Component Tests

[Source: architecture.md#Testing Strategy - Component Tests]

**Test File:** `tests/component/reports/LedgerSearch.test.tsx`

**Test Cases:**

```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { LedgerSearch } from '@/components/features/reports/LedgerSearch';

describe('LedgerSearch', () => {
  it('renders search input with placeholder', () => {
    render(<LedgerSearch value="" onChange={vi.fn()} />);
    expect(screen.getByPlaceholderText('Search by barber or service name...')).toBeInTheDocument();
  });

  it('calls onChange when user types', () => {
    const onChange = vi.fn();
    render(<LedgerSearch value="" onChange={onChange} />);

    fireEvent.change(screen.getByPlaceholderText(/search/i), {
      target: { value: 'john' }
    });

    expect(onChange).toHaveBeenCalledWith('john');
  });

  it('shows clear button when value is not empty', () => {
    render(<LedgerSearch value="john" onChange={vi.fn()} onClear={vi.fn()} />);
    expect(screen.getByLabelText('Clear search')).toBeInTheDocument();
  });

  it('hides clear button when value is empty', () => {
    render(<LedgerSearch value="" onChange={vi.fn()} onClear={vi.fn()} />);
    expect(screen.queryByLabelText('Clear search')).not.toBeInTheDocument();
  });

  it('calls onClear when clear button clicked', () => {
    const onClear = vi.fn();
    render(<LedgerSearch value="john" onChange={vi.fn()} onClear={onClear} />);

    fireEvent.click(screen.getByLabelText('Clear search'));

    expect(onClear).toHaveBeenCalled();
  });

  it('debounces search input by 300ms', async () => {
    vi.useFakeTimers();
    const onChange = vi.fn();

    render(<LedgerSearch value="" onChange={onChange} />);
    const input = screen.getByPlaceholderText(/search/i);

    // Type multiple characters rapidly
    fireEvent.change(input, { target: { value: 'j' } });
    fireEvent.change(input, { target: { value: 'jo' } });
    fireEvent.change(input, { target: { value: 'joh' } });

    // Should only call onChange for final value after 300ms
    act(() => vi.advanceTimersByTime(300));

    await waitFor(() => {
      expect(onChange).toHaveBeenLastCalledWith('joh');
    });

    vi.useRealTimers();
  });
});
```

#### E2E Tests

[Source: architecture.md#Testing Strategy - E2E Tests]

**Test File:** `tests/e2e/reports.spec.ts`

**Test Cases:**

```typescript
import { test, expect } from '@playwright/test'

test.describe('Ledger Search Functionality', () => {
  test.beforeEach(async ({ page }) => {
    // Login as manager and navigate to reports page
    await page.goto('/login')
    await page.click('text=Manager')
    await page.goto('/manager/reports')
  })

  test('searches by barber name and filters table', async ({ page }) => {
    // Type in search input
    await page.fill('[placeholder*="Search by barber"]', 'john')

    // Wait for debounce (300ms)
    await page.waitForTimeout(350)

    // Verify URL updated
    await expect(page).toHaveURL(/q=john/)

    // Verify table shows only matching rows
    const rows = page.locator('table tbody tr')
    await expect(rows).not.toHaveCount(0)

    // Check first row contains "john" in barber column
    await expect(rows.first()).toContainText(/john/i)
  })

  test('searches by service name and filters table', async ({ page }) => {
    await page.fill('[placeholder*="Search by barber"]', 'haircut')
    await page.waitForTimeout(350)

    // Verify table shows only haircut services
    const rows = page.locator('table tbody tr')
    await expect(rows.first()).toContainText(/haircut/i)
  })

  test('search is case-insensitive', async ({ page }) => {
    await page.fill('[placeholder*="Search by barber"]', 'JOHN')
    await page.waitForTimeout(350)

    // Should still match "john" or "John"
    await expect(page.locator('table tbody tr')).not.toHaveCount(0)
  })

  test('shows empty state when no results found', async ({ page }) => {
    await page.fill('[placeholder*="Search by barber"]', 'nonexistent')
    await page.waitForTimeout(350)

    // Verify empty state message
    await expect(
      page.locator('text=No results found for "nonexistent"')
    ).toBeVisible()
  })

  test('clear button clears search and resets table', async ({ page }) => {
    // Search for something
    await page.fill('[placeholder*="Search by barber"]', 'john')
    await page.waitForTimeout(350)

    // Click clear button
    await page.click('[aria-label="Clear search"]')

    // Verify search cleared
    await expect(page.locator('[placeholder*="Search by barber"]')).toHaveValue(
      ''
    )

    // Verify URL query param removed
    await expect(page).not.toHaveURL(/q=/)

    // Verify table shows all rows again
    await expect(page.locator('table tbody tr')).not.toHaveCount(0)
  })

  test('search persists in URL for shareable links', async ({ page }) => {
    await page.fill('[placeholder*="Search by barber"]', 'john')
    await page.waitForTimeout(350)

    // Get current URL
    const url = page.url()
    expect(url).toContain('q=john')

    // Reload page
    await page.reload()

    // Verify search persists
    await expect(page.locator('[placeholder*="Search by barber"]')).toHaveValue(
      'john'
    )
    await expect(page.locator('table tbody tr')).not.toHaveCount(0)
  })

  test('combines search with date range filter', async ({ page }) => {
    // Apply date range filter
    await page.click('text=Last 7 Days')

    // Then search
    await page.fill('[placeholder*="Search by barber"]', 'john')
    await page.waitForTimeout(350)

    // Verify both filters in URL
    await expect(page).toHaveURL(/from=.*&to=.*&q=john/)

    // Verify table shows results matching both filters
    await expect(page.locator('table tbody tr')).not.toHaveCount(0)
  })

  test('debounces search (does not re-query on every keystroke)', async ({
    page,
  }) => {
    // Type rapidly
    await page.type('[placeholder*="Search by barber"]', 'john', { delay: 50 })

    // URL should not update until after debounce
    await page.waitForTimeout(200) // Still debouncing
    await expect(page).not.toHaveURL(/q=john/)

    await page.waitForTimeout(150) // 350ms total, debounce complete
    await expect(page).toHaveURL(/q=john/)
  })

  test('new logs matching search appear in real-time', async ({
    page,
    context,
  }) => {
    // Open second browser as barber
    const barberPage = await context.newPage()
    await barberPage.goto('/login')
    await barberPage.click('text=Barber')
    await barberPage.click('text=John Barber')

    // Manager searches for "john"
    await page.fill('[placeholder*="Search by barber"]', 'john')
    await page.waitForTimeout(350)

    const initialCount = await page.locator('table tbody tr').count()

    // Barber logs a service
    await barberPage.click('text=Haircut')
    await barberPage.click('button:has-text("Log 1 Service")')

    // Manager approves (if needed for test setup)
    await page.click('text=Pending Approvals')
    await page.click('[aria-label="Approve"]')

    // Verify new log appears in manager's filtered table
    await expect(page.locator('table tbody tr')).toHaveCount(initialCount + 1)

    await barberPage.close()
  })
})
```

#### Integration Tests

**Test that search functionality:**

- Works correctly with date range filter (both filters combine)
- Updates in real-time when new matching logs added
- Maintains search state when navigating away and back
- Handles special characters in search query (e.g., "O'Brien")
- Performs well with 100+ service logs

## Change Log

| Date       | Version | Description            | Author          |
| ---------- | ------- | ---------------------- | --------------- |
| 2025-10-10 | v1.0    | Initial story creation | PM Agent (John) |

## Dev Agent Record

### Agent Model Used

{To be populated by dev agent}

### Debug Log References

{To be populated by dev agent}

### Completion Notes List

{To be populated by dev agent}

### File List

{To be populated by dev agent}

## QA Results

{To be populated by QA agent}
