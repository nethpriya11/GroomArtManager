# Story 3.6: Manager Pending Approvals Queue

## Status

Draft

## Story

**As a** manager,
**I want** to see all pending service logs in a dedicated table on my dashboard,
**so that** I can review and approve barber work efficiently.

## Acceptance Criteria

1. Manager dashboard includes "Pending Approvals" section with table
2. Table displays all service logs with `status: 'pending'` from Firestore
3. Columns: Barber (name), Service (name), Price ($XX.XX), Date (MM/DD/YYYY HH:MM), Actions (✓ ✗ icon buttons)
4. Real-time updates: New pending logs from barbers appear instantly in table
5. Table sorted by createdAt ascending (oldest first, FIFO queue)
6. Empty state: "No pending approvals. All caught up!"
7. Barber and Service names fetched via ID references (populated from `users` and `services` collections)
8. Actions column: Green checkmark button (approve), Red X button (reject)
9. Icon buttons have tooltips on hover: "Approve" and "Reject"
10. Touch targets meet mobile requirements (44x44px minimum)

## Tasks / Subtasks

- [ ] Create PendingApprovalsTable component (AC: 1, 3, 10)
  - [ ] Create new component file: components/features/service-logs/PendingApprovalsTable.tsx
  - [ ] Use ShadCN Table component for layout
  - [ ] Define table columns: Barber, Service, Price, Date, Actions
  - [ ] Apply dark theme styling (#1a1a1a / #141414 alternating rows)
  - [ ] Ensure action buttons meet 44x44px touch target requirement
- [ ] Implement real-time pending logs query (AC: 2, 4)
  - [ ] Create hook: usePendingServiceLogs() in hooks/
  - [ ] Use Firestore query: where('status', '==', 'pending')
  - [ ] Wrap in React Query with onSnapshot listener
  - [ ] Sort by createdAt ascending (oldest first - FIFO)
  - [ ] Configure staleTime: Infinity for real-time data
- [ ] Populate Barber and Service names (AC: 7)
  - [ ] Fetch barber from users collection using barberId reference
  - [ ] Fetch service from services collection using serviceId reference
  - [ ] Use separate queries or join data in component
  - [ ] Display loading state while names resolve
  - [ ] Handle case where barber/service not found (deleted)
- [ ] Format table columns (AC: 3)
  - [ ] Barber column: Display username from users collection
  - [ ] Service column: Display name from services collection
  - [ ] Price column: Format as currency ($XX.XX) using formatCurrency utility
  - [ ] Date column: Format as MM/DD/YYYY HH:MM using date-fns
  - [ ] Apply consistent column widths and alignment
- [ ] Add action buttons (AC: 8, 9)
  - [ ] Create approve button with green checkmark icon (✓)
  - [ ] Create reject button with red X icon (✗)
  - [ ] Add tooltips: "Approve" and "Reject" on hover
  - [ ] Use ShadCN Tooltip component
  - [ ] Position buttons in Actions column
  - [ ] Wire up onClick handlers for approve/reject mutations
- [ ] Implement empty state (AC: 6)
  - [ ] Check if pending logs array is empty
  - [ ] Display message: "No pending approvals. All caught up!"
  - [ ] Center message in table area
  - [ ] Use muted text color for empty state
- [ ] Add PendingApprovalsTable to Manager Dashboard (AC: 1)
  - [ ] Import component in ManagerDashboard.tsx
  - [ ] Add "Pending Approvals" section header
  - [ ] Position table below KPI cards
  - [ ] Apply consistent spacing and layout
- [ ] Configure Firestore composite index (AC: 5)
  - [ ] Add index to firestore.indexes.json
  - [ ] Fields: status (ASC), createdAt (ASC)
  - [ ] Deploy index via Firebase CLI
  - [ ] Verify index creation in Firebase console

## Dev Notes

### Data Query & Real-time Sync

[Source: architecture.md#Real-time Sync Engine]

**usePendingServiceLogs Hook Implementation:**

```typescript
// hooks/usePendingServiceLogs.ts
import {
  collection,
  query,
  where,
  orderBy,
  onSnapshot,
} from 'firebase/firestore'
import { useQuery } from '@tanstack/react-query'
import { db } from '@/lib/firebase/config'
import type { ServiceLog } from '@/types/firestore'

export function usePendingServiceLogs() {
  return useQuery({
    queryKey: ['serviceLogs', 'pending'],
    queryFn: () =>
      new Promise<ServiceLog[]>((resolve, reject) => {
        const q = query(
          collection(db, 'serviceLogs'),
          where('status', '==', 'pending'),
          orderBy('createdAt', 'asc') // FIFO: oldest first
        )

        const unsubscribe = onSnapshot(
          q,
          (snapshot) => {
            const logs = snapshot.docs.map(
              (doc) =>
                ({
                  id: doc.id,
                  ...doc.data(),
                }) as ServiceLog
            )
            resolve(logs)
          },
          reject
        )

        return () => unsubscribe()
      }),
    staleTime: Infinity, // Real-time data never stale
  })
}
```

**Required Firestore Index:**
[Source: architecture.md#Database Schema - Composite Indexes]

```json
{
  "collectionGroup": "serviceLogs",
  "queryScope": "COLLECTION",
  "fields": [
    { "fieldPath": "status", "order": "ASCENDING" },
    { "fieldPath": "createdAt", "order": "ASCENDING" }
  ]
}
```

### Data Population Pattern

[Source: architecture.md#ServiceLog Data Model]

**Fetching Referenced Data:**
The ServiceLog only stores IDs (barberId, serviceId). Names must be fetched from users and services collections.

**Approach 1 - Separate Queries (Recommended for MVP):**

```typescript
// Fetch all barbers and services once, join in memory
const { data: barbers } = useBarbers() // All barbers
const { data: services } = useServices() // All services
const { data: logs } = usePendingServiceLogs()

// Join data in component
const enrichedLogs = logs?.map((log) => ({
  ...log,
  barberName: barbers?.find((b) => b.id === log.barberId)?.username,
  serviceName: services?.find((s) => s.id === log.serviceId)?.name,
}))
```

**Approach 2 - Individual Fetches (More requests, always fresh):**

```typescript
// For each log, fetch barber and service
logs.map((log) => {
  const barber = useBarber(log.barberId)
  const service = useService(log.serviceId)
  // Display in row
})
```

**Recommendation:** Use Approach 1 (separate queries with in-memory join) for better performance and fewer Firestore reads.

### UI Components & Styling

[Source: architecture.md#Component Architecture]

**Required Components:**

- `PendingApprovalsTable.tsx` - Main table component
- ShadCN `Table` - Base table structure
- ShadCN `Button` - Action buttons
- ShadCN `Tooltip` - Hover tooltips for actions
- Icons: Lucide React `Check` and `X` icons

**Table Styling:**
[Source: architecture.md#Technology Stack - Tailwind CSS]

- Striped rows: Alternate between #1a1a1a and #141414
- Primary accent color: #f59e0b (for hover states)
- Dark theme: #0a0a0a background

**Touch Targets:**
[Source: architecture.md#Mobile Requirements]

- Action buttons minimum 44x44px for mobile accessibility
- Use ShadCN Button with `size="icon"` prop

### Column Formatting

**Price Formatting:**

```typescript
// lib/utils/format.ts
export function formatCurrency(amount: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
  }).format(amount)
}
```

**Date Formatting:**
[Source: architecture.md#Coding Standards - Date Handling]

```typescript
import { format } from 'date-fns'

// Convert Firestore Timestamp to Date
const date = log.createdAt.toDate()
const formatted = format(date, 'MM/dd/yyyy HH:mm')
```

### Real-time Updates

[Source: architecture.md#Core Workflows - Workflow 3]

When a barber logs a service:

1. Barber browser creates serviceLogs document with status='pending'
2. Firestore triggers onSnapshot callback in manager's browser
3. React Query updates cache with new log
4. PendingApprovalsTable re-renders with new row (fade-in animation)
5. Latency: <2 seconds from log creation to manager visibility

### Testing

[Source: architecture.md#Testing Strategy]

**Unit Tests (Vitest):**

- `tests/unit/hooks/usePendingServiceLogs.test.ts`
  - Mock Firestore onSnapshot
  - Verify query filters by status='pending'
  - Verify query sorts by createdAt ascending
  - Test real-time updates (simulate snapshot callback)

**Component Tests (React Testing Library):**

- `tests/component/service-logs/PendingApprovalsTable.test.tsx`
  - Render with pending logs - verify all rows displayed
  - Verify column headers: Barber, Service, Price, Date, Actions
  - Verify barber names populated from users collection
  - Verify service names populated from services collection
  - Verify price formatted as currency ($25.00)
  - Verify date formatted as MM/DD/YYYY HH:MM
  - Render with empty logs - verify empty state message shown
  - Verify approve button has "Approve" tooltip
  - Verify reject button has "Reject" tooltip
  - Verify action buttons meet 44x44px touch target

**Integration Tests:**

- `tests/component/dashboard/ManagerDashboard.test.tsx`
  - Full dashboard renders with PendingApprovalsTable
  - Mock pending logs in Firestore
  - Verify table displays logs with correct data
  - Test real-time update: add new pending log, verify row appears

**E2E Tests (Playwright):**

- `tests/e2e/approval-workflow/pending-queue.spec.ts`
  - As barber, log 3 services
  - As manager, open dashboard
  - Verify 3 pending logs appear in table
  - Verify logs sorted by oldest first (check createdAt order)
  - Verify barber names and service names correct
  - Hover over approve button - verify tooltip shows "Approve"
  - Hover over reject button - verify tooltip shows "Reject"
  - Open second manager browser - verify same pending logs visible (multi-client sync)

**Performance Tests:**

- Test with 100+ pending logs - verify table renders without lag
- Test pagination if >50 logs (AC does not specify pagination for pending queue)
- Verify Firestore index used (check Firebase console query metrics)

## Change Log

| Date       | Version | Description            | Author          |
| ---------- | ------- | ---------------------- | --------------- |
| 2025-10-10 | v1.0    | Initial story creation | PM Agent (John) |

## Dev Agent Record

### Agent Model Used

{To be populated by dev agent}

### Debug Log References

{To be populated by dev agent}

### Completion Notes List

{To be populated by dev agent}

### File List

{To be populated by dev agent}

## QA Results

{To be populated by QA agent}
