# Story 2.10: Real-time Catalog Updates

## Status

Draft

## Story

**As a** manager or barber,
**I want** service and barber lists to update in real-time without refreshing,
**so that** I always see current data when working collaboratively.

## Acceptance Criteria

1. Service catalog uses Firestore onSnapshot listener for real-time updates
2. Barber grid uses Firestore onSnapshot listener for real-time updates
3. New items added by any user appear instantly across all connected clients (within 2 seconds)
4. Updated items (edited services/barbers) reflect changes instantly
5. Deleted items disappear instantly
6. Multiple managers can work simultaneously without conflicts
7. Listeners automatically unsubscribe when user navigates away (cleanup in useEffect return)
8. Network errors (offline) show toast notification: "You're offline. Changes will sync when reconnected."
9. Animations for new items: 200ms fade-in + slide from top
10. No flickering or UI jank during real-time updates

## Tasks / Subtasks

- [ ] Implement real-time service catalog listener (AC: 1, 3, 4, 5)
  - [ ] Use Firestore onSnapshot in useServices hook
  - [ ] Wrap in React Query with staleTime: Infinity
  - [ ] Configure automatic re-rendering when data changes
  - [ ] Test: Add service in one browser tab, verify appears in another tab
  - [ ] Test: Edit service, verify updates appear instantly
  - [ ] Test: Delete service, verify disappears instantly
- [ ] Implement real-time barber grid listener (AC: 2, 3, 4, 5)
  - [ ] Use Firestore onSnapshot in useBarbers hook
  - [ ] Query users collection where role='barber'
  - [ ] Wrap in React Query with staleTime: Infinity
  - [ ] Test: Add barber, verify appears across all connected clients
  - [ ] Test: Edit barber, verify updates reflected instantly
  - [ ] Test: Delete barber, verify disappears instantly
- [ ] Verify multi-manager collaboration (AC: 6)
  - [ ] Test with 2 manager browsers open simultaneously
  - [ ] Manager A creates service, Manager B sees it instantly
  - [ ] Manager B edits service, Manager A sees update
  - [ ] Manager A deletes service, Manager B sees removal
  - [ ] No race conditions or conflicts in concurrent operations
  - [ ] Firestore handles write conflicts automatically
- [ ] Implement listener cleanup (AC: 7)
  - [ ] Return unsubscribe function from React Query queryFn
  - [ ] React Query automatically calls cleanup on unmount
  - [ ] Test: Navigate away from page, verify listener unsubscribes
  - [ ] Test: No memory leaks after multiple mount/unmount cycles
  - [ ] Use React DevTools Profiler to verify cleanup
- [ ] Handle offline/network errors (AC: 8)
  - [ ] Listen for Firestore onSnapshot error callback
  - [ ] Detect navigator.onLine events
  - [ ] Show toast: "You're offline. Changes will sync when reconnected."
  - [ ] Hide toast when connection restored
  - [ ] Firestore automatically syncs pending changes when back online
  - [ ] Display offline indicator in UI (optional enhancement)
- [ ] Implement new item animations (AC: 9)
  - [ ] Add CSS transitions: 200ms fade-in + slide from top
  - [ ] Use Framer Motion or CSS animations
  - [ ] Apply to newly added service cards
  - [ ] Apply to newly added barber cards
  - [ ] Use React key prop to trigger animation on new items
  - [ ] Example: animate-in fade-in slide-in-from-top duration-200
- [ ] Prevent UI flickering (AC: 10)
  - [ ] Use React Query's staleTime: Infinity to prevent refetching
  - [ ] Implement optimistic updates for mutations
  - [ ] Use stable keys for list items (Firestore document ID)
  - [ ] Avoid re-sorting or re-filtering on every update
  - [ ] Test: Rapidly add/edit/delete items, verify smooth updates
  - [ ] Use React.memo or useMemo for expensive list rendering

## Dev Notes

### Real-time Sync Architecture

[Source: architecture.md#Components - Real-time Sync Engine]

The real-time sync is built on Firestore's `onSnapshot` listener wrapped in React Query. This provides:

1. Automatic subscription management (subscribe on mount, unsubscribe on unmount)
2. Caching (prevents unnecessary re-renders)
3. Error handling
4. Integration with React component lifecycle

### useServices Hook Implementation

[Source: architecture.md#API Specification - Client-Side Firestore Operations]

```typescript
// hooks/useServices.ts
import { collection, onSnapshot, query, orderBy } from 'firebase/firestore'
import { useQuery } from '@tanstack/react-query'
import { db } from '@/lib/firebase/config'
import type { Service } from '@/types/firestore'

export function useServices() {
  return useQuery({
    queryKey: ['services'],
    queryFn: () =>
      new Promise<Service[]>((resolve, reject) => {
        const q = query(collection(db, 'services'), orderBy('name', 'asc'))

        const unsubscribe = onSnapshot(
          q,
          (snapshot) => {
            const services = snapshot.docs.map(
              (doc) =>
                ({
                  id: doc.id,
                  ...doc.data(),
                }) as Service
            )
            resolve(services)
          },
          (error) => {
            console.error('Services listener error:', error)
            reject(error)
          }
        )

        // Return cleanup function
        return () => unsubscribe()
      }),
    staleTime: Infinity, // Real-time data never stale
    refetchOnWindowFocus: false, // onSnapshot handles updates
    refetchOnReconnect: false,
  })
}
```

### useBarbers Hook Implementation

[Source: architecture.md#Components - Real-time Sync Engine]

```typescript
// hooks/useBarbers.ts
import {
  collection,
  onSnapshot,
  query,
  where,
  orderBy,
} from 'firebase/firestore'
import { useQuery } from '@tanstack/react-query'
import { db } from '@/lib/firebase/config'
import type { UserProfile } from '@/types/firestore'

export function useBarbers() {
  return useQuery({
    queryKey: ['barbers'],
    queryFn: () =>
      new Promise<UserProfile[]>((resolve, reject) => {
        const q = query(
          collection(db, 'users'),
          where('role', '==', 'barber'),
          orderBy('username', 'asc')
        )

        const unsubscribe = onSnapshot(
          q,
          (snapshot) => {
            const barbers = snapshot.docs.map(
              (doc) =>
                ({
                  id: doc.id,
                  ...doc.data(),
                }) as UserProfile
            )
            resolve(barbers)
          },
          (error) => {
            console.error('Barbers listener error:', error)
            reject(error)
          }
        )

        return () => unsubscribe()
      }),
    staleTime: Infinity,
    refetchOnWindowFocus: false,
    refetchOnReconnect: false,
  })
}
```

### Offline Detection and Handling

[Source: architecture.md#Coding Standards - Error Handling]

Implement offline detection:

```typescript
// hooks/useOfflineDetection.ts
import { useEffect } from 'react'
import { toast } from 'sonner'

export function useOfflineDetection() {
  useEffect(() => {
    const handleOffline = () => {
      toast.error("You're offline. Changes will sync when reconnected.", {
        id: 'offline-toast',
        duration: Infinity,
      })
    }

    const handleOnline = () => {
      toast.dismiss('offline-toast')
      toast.success('Back online. Syncing changes...')
    }

    window.addEventListener('offline', handleOffline)
    window.addEventListener('online', handleOnline)

    // Check initial state
    if (!navigator.onLine) {
      handleOffline()
    }

    return () => {
      window.removeEventListener('offline', handleOffline)
      window.removeEventListener('online', handleOnline)
    }
  }, [])
}
```

Use in app layout:

```typescript
// app/layout.tsx or app/(auth)/layout.tsx
import { useOfflineDetection } from '@/hooks/useOfflineDetection';

export default function Layout({ children }) {
  useOfflineDetection();
  return <>{children}</>;
}
```

### Animation Implementation

[Source: architecture.md#Tech Stack - Tailwind CSS]

**Option 1: Tailwind CSS Animations**

```tsx
// components/features/services/ServiceCard.tsx
export function ServiceCard({ service }: { service: Service }) {
  return (
    <Card
      key={service.id}
      className="animate-in fade-in slide-in-from-top-2 duration-200"
    >
      {/* Card content */}
    </Card>
  )
}
```

**Option 2: Framer Motion** (more control):

```tsx
import { motion } from 'framer-motion'

export function ServiceCard({ service }: { service: Service }) {
  return (
    <motion.div
      key={service.id}
      initial={{ opacity: 0, y: -20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
      transition={{ duration: 0.2 }}
    >
      <Card>{/* Card content */}</Card>
    </motion.div>
  )
}
```

For Framer Motion, wrap grid in `<AnimatePresence>`:

```tsx
<AnimatePresence>
  {services.map((service) => (
    <ServiceCard key={service.id} service={service} />
  ))}
</AnimatePresence>
```

### Preventing UI Flickering

[Source: architecture.md#Architectural Patterns - Real-time Data Synchronization]

**Best Practices:**

1. **Stable Keys**: Always use Firestore document ID as React key
2. **Optimistic Updates**: Apply changes to cache before Firestore confirms
3. **Memoization**: Use React.memo for card components
4. **Avoid Re-sorting**: Sort once in query, not in component

```tsx
// Memoize service card to prevent unnecessary re-renders
export const ServiceCard = React.memo(function ServiceCard({ service }: Props) {
  // Component implementation
})

// Use stable key in list
{
  services.map((service) => <ServiceCard key={service.id} service={service} />)
}
```

### Concurrent Manager Operations

[Source: architecture.md#Core Workflows - Real-time Synchronization]

Firestore handles concurrent writes automatically:

- **Optimistic Locking**: Last write wins (default behavior)
- **No Code Needed**: Firestore's architecture prevents conflicts
- **Real-time Propagation**: All connected clients receive updates via onSnapshot

Example scenario:

1. Manager A edits Service X at 10:00:00.100
2. Manager B edits Service X at 10:00:00.200
3. Manager B's change wins (last write)
4. Both managers see Manager B's version via onSnapshot
5. No error, no conflict - seamless UX

For critical operations requiring transactions (e.g., financial), use Firestore transactions or batch writes (not needed for MVP).

### Project Structure

[Source: architecture.md#Unified Project Structure]

**Files to create/modify:**

- `hooks/useServices.ts` - Real-time services hook
- `hooks/useBarbers.ts` - Real-time barbers hook
- `hooks/useOfflineDetection.ts` - Offline detection hook
- `components/features/services/ServiceCard.tsx` - Add animations
- `components/features/barbers/BarberCard.tsx` - Add animations
- `app/(auth)/layout.tsx` - Add offline detection

### Testing

#### Component Tests

[Source: architecture.md#Testing Strategy - Component Tests]

**Tests Required:**

1. `tests/component/services/ServiceGrid.test.tsx`
   - Renders initial services from hook data
   - Updates when new service added to mock data
   - Updates when service edited in mock data
   - Removes service when deleted from mock data
   - Applies animation classes to new items
   - Does not flicker during rapid updates

2. `tests/component/barbers/BarberGrid.test.tsx`
   - Same tests as ServiceGrid for barbers

#### Integration Tests

[Source: architecture.md#Testing Strategy - Integration Tests]

**Test with mocked Firestore:**

1. `tests/integration/realtime/realtime-sync.test.tsx`
   - Mock onSnapshot to simulate real-time updates
   - Add document to mock, verify appears in UI
   - Modify document in mock, verify UI updates
   - Delete document from mock, verify UI removes
   - Simulate onSnapshot error, verify error handling
   - Test listener cleanup on component unmount

#### E2E Tests

[Source: architecture.md#Testing Strategy - E2E Tests]

**Playwright tests with Firebase Emulator:**

1. `tests/e2e/real-time-sync.spec.ts`
   - Open app in two browser contexts (Manager A and B)
   - Manager A: Create service "Haircut - $25"
   - Manager B: Verify service appears within 2 seconds
   - Manager B: Edit service price to $30
   - Manager A: Verify price updates within 2 seconds
   - Manager A: Delete service
   - Manager B: Verify service disappears within 2 seconds
   - Repeat for barbers
   - Test with network throttling (3G) - verify < 5s latency

2. `tests/e2e/offline-handling.spec.ts`
   - Open app, verify online
   - Simulate offline (browser.setOffline(true))
   - Verify offline toast appears
   - Attempt to create service (should queue)
   - Restore online (browser.setOffline(false))
   - Verify online toast and sync message
   - Verify queued service created successfully

#### Unit Tests

[Source: architecture.md#Testing Strategy - Frontend Unit Tests]

**Hook tests:**

1. `tests/unit/hooks/useServices.test.ts`
   - Returns loading state initially
   - Returns data from Firestore onSnapshot
   - Updates data when snapshot changes
   - Calls unsubscribe on unmount
   - Handles errors from onSnapshot

2. `tests/unit/hooks/useOfflineDetection.test.ts`
   - Shows offline toast when navigator.onLine is false
   - Shows online toast when connection restored
   - Cleans up event listeners on unmount
   - Dismisses offline toast when back online

### Performance Considerations

[Source: architecture.md#Architectural Patterns - Real-time Data Synchronization]

**Firestore Pricing:**

- Each onSnapshot listener: 1 read per document on initial load
- Each update: 1 read per updated document
- Estimated for 50 services, 10 barbers, 5 concurrent users:
  - Initial load: 60 reads × 5 users = 300 reads
  - Daily updates: ~100 edits × 5 users = 500 reads
  - Total: ~800 reads/day = well within free tier (50K reads/day)

**Optimization Tips:**

- Use `staleTime: Infinity` to prevent refetching
- Implement pagination for large datasets (not needed for MVP)
- Use Firestore query limits if catalog grows (limit: 100)
- Consider indexing frequently filtered fields

## Change Log

| Date       | Version | Description            | Author          |
| ---------- | ------- | ---------------------- | --------------- |
| 2025-10-10 | v1.0    | Initial story creation | PM Agent (John) |

## Dev Agent Record

### Agent Model Used

{To be populated by dev agent}

### Debug Log References

{To be populated by dev agent}

### Completion Notes List

{To be populated by dev agent}

### File List

{To be populated by dev agent}

## QA Results

{To be populated by QA agent}
