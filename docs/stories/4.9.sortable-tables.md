# Story 4.9: Sortable Tables

## Status

Draft

## Story

**As a** manager,
**I want** to sort tables by clicking column headers,
**so that** I can analyze data from different perspectives.

## Acceptance Criteria

1. All tables on reports page have sortable columns (Leaderboards, Financial Ledger)
2. Clicking column header sorts by that column: First click ascending, second click descending, third click returns to default
3. Sort indicator icon displayed in header: ↑ (ascending) or ↓ (descending)
4. Currently sorted column highlighted with primary accent color (#f59e0b)
5. Financial Ledger sortable by: Date, Barber (alphabetical), Service (alphabetical), Price, Commission Amount
6. Leaderboards sortable by: Rank, Barber/Service, Services Count, Revenue
7. Default sort order preserved when changing date range (sort persists)
8. Sort state saved in URL query param (?sort=price&order=desc)
9. Keyboard accessible: Tab to header, Enter to toggle sort
10. Real-time: New rows inserted in correct sorted position

## Tasks / Subtasks

- [ ] Implement sortable table header component (AC: 1, 2, 3, 4)
  - [ ] Create SortableTableHeader component with click handler
  - [ ] Add sort indicator icons: ↑ (ascending) or ↓ (descending)
  - [ ] Highlight currently sorted column with primary accent color (#f59e0b)
  - [ ] Toggle sort order: ascending → descending → default (3-state cycle)
- [ ] Add sorting to Financial Ledger table (AC: 5)
  - [ ] Implement sort by Date (createdAt)
  - [ ] Implement sort by Barber name (alphabetical)
  - [ ] Implement sort by Service name (alphabetical)
  - [ ] Implement sort by Price (numerical)
  - [ ] Implement sort by Commission Amount (numerical)
- [ ] Add sorting to Leaderboards tables (AC: 6)
  - [ ] Top Barbers: Sort by Rank, Barber (alphabetical), Services Count, Revenue
  - [ ] Top Services: Sort by Rank, Service (alphabetical), Count, Revenue
  - [ ] Default sort: Revenue descending
- [ ] Persist sort state across filters (AC: 7)
  - [ ] Maintain sort order when date range changes
  - [ ] Maintain sort order when search query changes
  - [ ] Store sort configuration in component state
- [ ] Persist sort state in URL query params (AC: 8)
  - [ ] Add sort and order params: ?sort=price&order=desc
  - [ ] Parse query params on page load to restore sort state
  - [ ] Update URL when sort changes (shallow routing)
- [ ] Add keyboard accessibility (AC: 9)
  - [ ] Make headers focusable with Tab key
  - [ ] Toggle sort with Enter/Space key
  - [ ] Add aria-sort attribute to headers
  - [ ] Announce sort changes to screen readers
- [ ] Implement real-time sorted insertion (AC: 10)
  - [ ] New rows insert in correct sorted position
  - [ ] Use binary search for insertion point
  - [ ] Maintain sort order with real-time updates

## Dev Notes

### Sortable Table Architecture

[Source: architecture.md#Components - Atomic Design]

**Component Structure:**

```
components/
├── ui/
│   └── table.tsx                    # ShadCN Table component
└── features/
    └── reports/
        ├── SortableTable.tsx        # Reusable sortable table wrapper
        ├── SortableTableHeader.tsx  # Sortable column header
        ├── FinancialLedger.tsx      # Uses SortableTable
        └── Leaderboard.tsx          # Uses SortableTable
```

### Sort State Management

[Source: architecture.md#State Management - React State]

**Sort Configuration Type:**

```typescript
type SortConfig = {
  column: string
  order: 'asc' | 'desc' | null
}

// Component state
const [sortConfig, setSortConfig] = useState<SortConfig>({
  column: 'createdAt',
  order: 'desc', // Default: newest first
})
```

**Sort Toggle Logic (3-state cycle):**

```typescript
function handleSort(column: string) {
  setSortConfig((prev) => {
    // If clicking different column, start with ascending
    if (prev.column !== column) {
      return { column, order: 'asc' }
    }

    // If same column, cycle through states
    if (prev.order === 'asc') return { column, order: 'desc' }
    if (prev.order === 'desc') return { column: null, order: null } // Back to default
    return { column, order: 'asc' } // Should not reach here
  })
}
```

### Sortable Table Header Component

[Source: architecture.md#Components - ShadCN UI]

**Implementation:**

```typescript
import { ArrowUp, ArrowDown, ChevronsUpDown } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface SortableTableHeaderProps {
  column: string;
  label: string;
  currentSort: SortConfig;
  onSort: (column: string) => void;
}

function SortableTableHeader({ column, label, currentSort, onSort }: SortableTableHeaderProps) {
  const isSorted = currentSort.column === column;
  const sortOrder = isSorted ? currentSort.order : null;

  const getSortIcon = () => {
    if (!isSorted || sortOrder === null) return <ChevronsUpDown className="ml-2 h-4 w-4" />;
    if (sortOrder === 'asc') return <ArrowUp className="ml-2 h-4 w-4" />;
    return <ArrowDown className="ml-2 h-4 w-4" />;
  };

  return (
    <th>
      <Button
        variant="ghost"
        onClick={() => onSort(column)}
        onKeyDown={(e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            onSort(column);
          }
        }}
        className={isSorted ? 'text-primary' : ''}
        aria-sort={sortOrder === 'asc' ? 'ascending' : sortOrder === 'desc' ? 'descending' : 'none'}
      >
        {label}
        {getSortIcon()}
      </Button>
    </th>
  );
}
```

### Sort Functions

[Source: architecture.md#Utilities]

**Generic Sort Function:**

```typescript
// lib/utils/sorting.ts
type SortOrder = 'asc' | 'desc' | null

function sortData<T>(data: T[], column: keyof T, order: SortOrder): T[] {
  if (order === null) return data // No sort, return original order

  return [...data].sort((a, b) => {
    const aVal = a[column]
    const bVal = b[column]

    // Handle null/undefined
    if (aVal == null) return 1
    if (bVal == null) return -1

    // String comparison (case-insensitive)
    if (typeof aVal === 'string' && typeof bVal === 'string') {
      const comparison = aVal.toLowerCase().localeCompare(bVal.toLowerCase())
      return order === 'asc' ? comparison : -comparison
    }

    // Numeric/Date comparison
    if (aVal < bVal) return order === 'asc' ? -1 : 1
    if (aVal > bVal) return order === 'asc' ? 1 : -1
    return 0
  })
}
```

**Financial Ledger Sort Example:**

```typescript
const sortedLogs = useMemo(() => {
  let sorted = [...serviceLogs]

  // Apply date range filter first
  sorted = sorted.filter((log) => isWithinDateRange(log, dateRange))

  // Apply search filter
  sorted = sorted.filter((log) => matchesSearch(log, searchQuery))

  // Apply sort
  if (sortConfig.order) {
    sorted = sortData(sorted, sortConfig.column, sortConfig.order)
  }

  return sorted
}, [serviceLogs, dateRange, searchQuery, sortConfig])
```

### URL Query Parameter Persistence

[Source: architecture.md#Next.js App Router]

**Implementation:**

```typescript
import { useRouter, useSearchParams } from 'next/navigation'

function FinancialLedger() {
  const router = useRouter()
  const searchParams = useSearchParams()

  // Initialize sort from URL
  const [sortConfig, setSortConfig] = useState<SortConfig>(() => ({
    column: searchParams.get('sort') || 'createdAt',
    order: (searchParams.get('order') as SortOrder) || 'desc',
  }))

  // Update URL when sort changes
  useEffect(() => {
    const params = new URLSearchParams(searchParams)

    if (sortConfig.order) {
      params.set('sort', sortConfig.column)
      params.set('order', sortConfig.order)
    } else {
      params.delete('sort')
      params.delete('order')
    }

    router.push(`?${params.toString()}`, { shallow: true })
  }, [sortConfig])
}
```

**Combined URL Params:**

```
/manager/reports?from=2025-10-01&to=2025-10-31&q=haircut&sort=price&order=desc
```

### Real-time Sorted Insertion

[Source: architecture.md#Real-time Sync Engine]

**Approach 1: Re-sort entire array (simpler for MVP):**

```typescript
// When new log arrives via onSnapshot
const newLog = snapshot.docChanges().find((change) => change.type === 'added')

if (newLog) {
  setServiceLogs((prev) => {
    const updated = [...prev, newLog.doc.data()]
    // Re-sort entire array
    return sortData(updated, sortConfig.column, sortConfig.order)
  })
}
```

**Approach 2: Binary search insertion (more efficient):**

```typescript
function insertSorted<T>(
  array: T[],
  item: T,
  column: keyof T,
  order: SortOrder
): T[] {
  if (order === null) return [...array, item] // No sort, append

  // Binary search for insertion point
  let left = 0
  let right = array.length

  while (left < right) {
    const mid = Math.floor((left + right) / 2)
    const comparison = compare(item[column], array[mid][column], order)

    if (comparison < 0) {
      right = mid
    } else {
      left = mid + 1
    }
  }

  // Insert at correct position
  const newArray = [...array]
  newArray.splice(left, 0, item)
  return newArray
}

function compare<T>(a: T, b: T, order: SortOrder): number {
  if (a < b) return order === 'asc' ? -1 : 1
  if (a > b) return order === 'asc' ? 1 : -1
  return 0
}
```

### Accessibility

[Source: architecture.md#Accessibility]

**ARIA Attributes:**

```typescript
// Table header
<th aria-sort={sortOrder === 'asc' ? 'ascending' : sortOrder === 'desc' ? 'descending' : 'none'}>

// Sort button
<Button
  role="button"
  tabIndex={0}
  aria-label={`Sort by ${label} ${sortOrder === 'asc' ? 'ascending' : 'descending'}`}
>
```

**Keyboard Navigation:**

- Tab: Move focus between sortable headers
- Enter/Space: Toggle sort on focused header
- Screen reader announces: "Sorted by Price, descending"

### Testing

#### Unit Tests

[Source: architecture.md#Testing Strategy - Frontend Unit Tests]

**Test File:** `tests/unit/utils/sorting.test.ts`

**Test Cases:**

```typescript
import { sortData } from '@/lib/utils/sorting'

describe('sortData', () => {
  const mockData = [
    { name: 'Charlie', age: 30, createdAt: new Date('2025-10-01') },
    { name: 'alice', age: 25, createdAt: new Date('2025-10-03') },
    { name: 'Bob', age: 35, createdAt: new Date('2025-10-02') },
  ]

  it('sorts strings alphabetically ascending (case-insensitive)', () => {
    const sorted = sortData(mockData, 'name', 'asc')
    expect(sorted.map((d) => d.name)).toEqual(['alice', 'Bob', 'Charlie'])
  })

  it('sorts strings alphabetically descending', () => {
    const sorted = sortData(mockData, 'name', 'desc')
    expect(sorted.map((d) => d.name)).toEqual(['Charlie', 'Bob', 'alice'])
  })

  it('sorts numbers ascending', () => {
    const sorted = sortData(mockData, 'age', 'asc')
    expect(sorted.map((d) => d.age)).toEqual([25, 30, 35])
  })

  it('sorts numbers descending', () => {
    const sorted = sortData(mockData, 'age', 'desc')
    expect(sorted.map((d) => d.age)).toEqual([35, 30, 25])
  })

  it('sorts dates chronologically', () => {
    const sorted = sortData(mockData, 'createdAt', 'asc')
    expect(sorted[0].name).toBe('Charlie') // Oct 1
    expect(sorted[2].name).toBe('alice') // Oct 3
  })

  it('returns original order when order is null', () => {
    const sorted = sortData(mockData, 'name', null)
    expect(sorted).toEqual(mockData)
  })

  it('handles null/undefined values', () => {
    const dataWithNulls = [
      { name: 'Alice', value: 10 },
      { name: 'Bob', value: null },
      { name: 'Charlie', value: 5 },
    ]

    const sorted = sortData(dataWithNulls, 'value', 'asc')
    expect(sorted[0].value).toBe(5)
    expect(sorted[1].value).toBe(10)
    expect(sorted[2].value).toBe(null) // Nulls at end
  })

  it('does not mutate original array', () => {
    const original = [...mockData]
    sortData(mockData, 'age', 'asc')
    expect(mockData).toEqual(original)
  })
})
```

#### Component Tests

[Source: architecture.md#Testing Strategy - Component Tests]

**Test File:** `tests/component/reports/SortableTableHeader.test.tsx`

**Test Cases:**

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { SortableTableHeader } from '@/components/features/reports/SortableTableHeader';

describe('SortableTableHeader', () => {
  const mockOnSort = vi.fn();

  it('renders column label', () => {
    render(
      <SortableTableHeader
        column="price"
        label="Price"
        currentSort={{ column: 'createdAt', order: 'desc' }}
        onSort={mockOnSort}
      />
    );

    expect(screen.getByText('Price')).toBeInTheDocument();
  });

  it('shows unsorted icon when column not sorted', () => {
    render(
      <SortableTableHeader
        column="price"
        label="Price"
        currentSort={{ column: 'createdAt', order: 'desc' }}
        onSort={mockOnSort}
      />
    );

    expect(screen.getByRole('button')).toHaveTextContent('Price');
    // Should show ChevronsUpDown icon
  });

  it('shows ascending icon when sorted ascending', () => {
    render(
      <SortableTableHeader
        column="price"
        label="Price"
        currentSort={{ column: 'price', order: 'asc' }}
        onSort={mockOnSort}
      />
    );

    // Should show ArrowUp icon
    expect(screen.getByRole('button')).toHaveAttribute('aria-sort', 'ascending');
  });

  it('shows descending icon when sorted descending', () => {
    render(
      <SortableTableHeader
        column="price"
        label="Price"
        currentSort={{ column: 'price', order: 'desc' }}
        onSort={mockOnSort}
      />
    );

    expect(screen.getByRole('button')).toHaveAttribute('aria-sort', 'descending');
  });

  it('highlights sorted column with primary color', () => {
    const { container } = render(
      <SortableTableHeader
        column="price"
        label="Price"
        currentSort={{ column: 'price', order: 'asc' }}
        onSort={mockOnSort}
      />
    );

    expect(screen.getByRole('button')).toHaveClass('text-primary');
  });

  it('calls onSort when clicked', () => {
    render(
      <SortableTableHeader
        column="price"
        label="Price"
        currentSort={{ column: 'createdAt', order: 'desc' }}
        onSort={mockOnSort}
      />
    );

    fireEvent.click(screen.getByRole('button'));

    expect(mockOnSort).toHaveBeenCalledWith('price');
  });

  it('calls onSort when Enter key pressed', () => {
    render(
      <SortableTableHeader
        column="price"
        label="Price"
        currentSort={{ column: 'createdAt', order: 'desc' }}
        onSort={mockOnSort}
      />
    );

    fireEvent.keyDown(screen.getByRole('button'), { key: 'Enter' });

    expect(mockOnSort).toHaveBeenCalledWith('price');
  });

  it('calls onSort when Space key pressed', () => {
    render(
      <SortableTableHeader
        column="price"
        label="Price"
        currentSort={{ column: 'createdAt', order: 'desc' }}
        onSort={mockOnSort}
      />
    );

    fireEvent.keyDown(screen.getByRole('button'), { key: ' ' });

    expect(mockOnSort).toHaveBeenCalledWith('price');
  });

  it('is keyboard focusable', () => {
    render(
      <SortableTableHeader
        column="price"
        label="Price"
        currentSort={{ column: 'createdAt', order: 'desc' }}
        onSort={mockOnSort}
      />
    );

    const button = screen.getByRole('button');
    button.focus();

    expect(button).toHaveFocus();
  });
});
```

#### E2E Tests

[Source: architecture.md#Testing Strategy - E2E Tests]

**Test File:** `tests/e2e/reports.spec.ts`

**Test Cases:**

```typescript
import { test, expect } from '@playwright/test'

test.describe('Sortable Tables', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/login')
    await page.click('text=Manager')
    await page.goto('/manager/reports')
  })

  test('sorts Financial Ledger by Price ascending', async ({ page }) => {
    // Click Price header once (ascending)
    await page.click('th:has-text("Price")')

    // Verify URL updated
    await expect(page).toHaveURL(/sort=price&order=asc/)

    // Verify table sorted (check first and last row prices)
    const rows = page.locator('table tbody tr')
    const firstPrice = await rows
      .first()
      .locator('td:nth-child(4)')
      .textContent()
    const lastPrice = await rows.last().locator('td:nth-child(4)').textContent()

    expect(parseFloat(firstPrice.replace('$', ''))).toBeLessThan(
      parseFloat(lastPrice.replace('$', ''))
    )

    // Verify ascending icon visible
    await expect(
      page.locator('th:has-text("Price") svg[data-icon="arrow-up"]')
    ).toBeVisible()
  })

  test('cycles through sort states: asc → desc → default', async ({ page }) => {
    const priceHeader = page.locator('th:has-text("Price")')

    // First click: ascending
    await priceHeader.click()
    await expect(page).toHaveURL(/order=asc/)

    // Second click: descending
    await priceHeader.click()
    await expect(page).toHaveURL(/order=desc/)

    // Third click: back to default (no sort param)
    await priceHeader.click()
    await expect(page).not.toHaveURL(/sort=price/)
  })

  test('sorts Top Barbers leaderboard by Revenue', async ({ page }) => {
    // Locate Top Barbers table
    const leaderboard = page.locator('text=Top Barbers').locator('..')

    // Click Revenue header
    await leaderboard.locator('th:has-text("Revenue")').click()

    // Verify table sorted
    const rows = leaderboard.locator('tbody tr')
    const firstRevenue = await rows
      .first()
      .locator('td:last-child')
      .textContent()
    const secondRevenue = await rows
      .nth(1)
      .locator('td:last-child')
      .textContent()

    expect(parseFloat(firstRevenue.replace('$', ''))).toBeLessThanOrEqual(
      parseFloat(secondRevenue.replace('$', ''))
    )
  })

  test('highlights currently sorted column', async ({ page }) => {
    await page.click('th:has-text("Price")')

    // Verify Price header highlighted
    const priceHeader = page.locator('th:has-text("Price") button')
    await expect(priceHeader).toHaveClass(/text-primary/)
  })

  test('preserves sort when date range changes', async ({ page }) => {
    // Sort by Price ascending
    await page.click('th:has-text("Price")')
    await expect(page).toHaveURL(/sort=price&order=asc/)

    // Change date range
    await page.click('text=Last 7 Days')

    // Verify sort persists
    await expect(page).toHaveURL(/sort=price&order=asc/)

    // Verify Price header still highlighted
    await expect(page.locator('th:has-text("Price") button')).toHaveClass(
      /text-primary/
    )
  })

  test('preserves sort when search query changes', async ({ page }) => {
    // Sort by Barber name
    await page.click('th:has-text("Barber")')

    // Search
    await page.fill('[placeholder*="Search"]', 'john')
    await page.waitForTimeout(350) // Debounce

    // Verify sort persists
    await expect(page).toHaveURL(/sort=barber&.*q=john/)
  })

  test('restores sort from URL on page load', async ({ page }) => {
    // Navigate with sort params
    await page.goto('/manager/reports?sort=price&order=desc')

    // Verify Price header shows descending
    await expect(page.locator('th:has-text("Price") button')).toHaveClass(
      /text-primary/
    )
    await expect(
      page.locator('th:has-text("Price") svg[data-icon="arrow-down"]')
    ).toBeVisible()
  })

  test('keyboard navigation: Tab to headers and Enter to sort', async ({
    page,
  }) => {
    // Tab to first sortable header
    await page.keyboard.press('Tab')
    await page.keyboard.press('Tab') // Navigate to table headers

    // Press Enter to sort
    await page.keyboard.press('Enter')

    // Verify sort applied
    await expect(page).toHaveURL(/sort=/)
  })

  test('new logs insert in correct sorted position', async ({
    page,
    context,
  }) => {
    // Sort by Price ascending
    await page.click('th:has-text("Price")')

    // Get initial row count and first price
    const initialCount = await page.locator('table tbody tr').count()
    const firstPrice = await page
      .locator('table tbody tr')
      .first()
      .locator('td:nth-child(4)')
      .textContent()

    // Open barber page to log service
    const barberPage = await context.newPage()
    await barberPage.goto('/login')
    await barberPage.click('text=Barber')
    await barberPage.click('text=John Barber')

    // Log a service (assume price is lower than current first)
    await barberPage.click('text=Basic Shave') // Assume this is cheapest service
    await barberPage.click('button:has-text("Log 1 Service")')

    // Manager approves
    await page.click('text=Pending Approvals')
    await page.click('[aria-label="Approve"]').first()

    // Navigate back to ledger
    await page.goto('/manager/reports?sort=price&order=asc')

    // Verify new log inserted in correct position
    await expect(page.locator('table tbody tr')).toHaveCount(initialCount + 1)

    // Verify table still sorted (first price <= second price)
    const rows = page.locator('table tbody tr')
    const newFirstPrice = await rows
      .first()
      .locator('td:nth-child(4)')
      .textContent()
    const secondPrice = await rows
      .nth(1)
      .locator('td:nth-child(4)')
      .textContent()

    expect(parseFloat(newFirstPrice.replace('$', ''))).toBeLessThanOrEqual(
      parseFloat(secondPrice.replace('$', ''))
    )

    await barberPage.close()
  })
})
```

#### Integration Tests

**Test that sorting:**

- Works correctly with pagination (first page sorted, navigate to page 2 also sorted)
- Maintains sort order with real-time updates
- Handles edge cases: all values equal, single row, empty table
- Performs well with 1000+ rows (sort completes in <100ms)

## Change Log

| Date       | Version | Description            | Author          |
| ---------- | ------- | ---------------------- | --------------- |
| 2025-10-10 | v1.0    | Initial story creation | PM Agent (John) |

## Dev Agent Record

### Agent Model Used

{To be populated by dev agent}

### Debug Log References

{To be populated by dev agent}

### Completion Notes List

{To be populated by dev agent}

### File List

{To be populated by dev agent}

## QA Results

{To be populated by QA agent}
