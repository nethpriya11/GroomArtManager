# Story 3.10: Commission Calculation & Storage

## Status

Draft

## Story

**As a** system,
**I want** commission amounts calculated and stored when service logs are created,
**so that** commission rates are locked in at logging time and financial reports are accurate.

## Acceptance Criteria

1. When service log created: commissionRate and price snapshotted from current barber profile and service
2. commissionAmount calculated: price × commissionRate, rounded to 2 decimal places
3. Formula implemented as utility function: `calculateCommission(price: number, rate: number): number`
4. Unit tests verify calculation accuracy: $50 × 0.45 = $22.50, $100 × 0.50 = $50.00
5. Stored values immutable: If barber's commission rate or service price later changes, existing logs retain original values
6. This ensures historical accuracy for payroll and reporting
7. If commission rate = 0 (e.g., manager without commission): commissionAmount = 0
8. Negative prices rejected by validation (cannot create negative commission)
9. Commission amounts displayed in barber daily stats, financial ledger, and reports
10. TypeScript types enforce number types for price, rate, amount (no string math)

## Tasks / Subtasks

- [ ] Create calculateCommission utility function (AC: 2, 3, 7, 8)
  - [ ] Create lib/utils/calculations.ts file
  - [ ] Implement calculateCommission(price: number, rate: number): number
  - [ ] Round result to 2 decimal places using Math.round()
  - [ ] Handle edge case: commission rate = 0 returns 0
  - [ ] Add JSDoc documentation with examples
  - [ ] Export function for use across codebase
- [ ] Add input validation (AC: 8, 10)
  - [ ] Create Zod schema for service log creation
  - [ ] Validate price is positive number (> 0)
  - [ ] Validate commissionRate is between 0.0 and 1.0
  - [ ] Validate all numeric fields are numbers (not strings)
  - [ ] Reject negative prices with validation error
- [ ] Implement snapshot logic in service logging (AC: 1, 5, 6)
  - [ ] In logServices() function: fetch current service price
  - [ ] In logServices() function: fetch current barber commissionRate
  - [ ] Store snapshotted values in serviceLogs document
  - [ ] In logServiceForBarber(): same snapshot logic for manager logging
  - [ ] Ensure stored values never update when source data changes
  - [ ] Document immutability in code comments
- [ ] Create TypeScript types (AC: 10)
  - [ ] Define ServiceLog interface in types/firestore.ts
  - [ ] Ensure all fields typed as number (not string | number)
  - [ ] Add type guards if needed for runtime validation
  - [ ] Use strict TypeScript checks (noUncheckedIndexedAccess: true)
- [ ] Integrate calculation in all log creation paths (AC: 9)
  - [ ] Barber logs services: use calculateCommission()
  - [ ] Manager logs on behalf of barber: use calculateCommission()
  - [ ] Display commissionAmount in barber daily stats
  - [ ] Display commissionAmount in financial ledger
  - [ ] Display commissionAmount in reports
- [ ] Write comprehensive unit tests (AC: 4)
  - [ ] Test: $50 × 0.45 = $22.50
  - [ ] Test: $100 × 0.50 = $50.00
  - [ ] Test: $25 × 0.45 = $11.25
  - [ ] Test: $0 × 0.45 = $0.00
  - [ ] Test: $100 × 0 = $0.00
  - [ ] Test: Rounding edge cases (e.g., $33.33 × 0.333 = $11.10)

## Dev Notes

### Commission Calculation Function

[Source: architecture.md#Components - Service Logging Service]

The commission calculation is a pure utility function that must be used consistently across all service log creation paths to ensure accuracy.

**Function Location:** `lib/utils/calculations.ts`

**Implementation:**

```typescript
/**
 * Calculates commission amount from price and rate.
 * @param price - Service price in dollars (e.g., 25.00)
 * @param rate - Commission rate as decimal (e.g., 0.45 for 45%)
 * @returns Commission amount rounded to 2 decimal places
 * @example
 * calculateCommission(50, 0.45) // Returns 22.50
 * calculateCommission(100, 0.50) // Returns 50.00
 */
export function calculateCommission(price: number, rate: number): number {
  return Math.round(price * rate * 100) / 100 // Round to 2 decimals
}
```

**Rationale for Rounding:** JavaScript floating-point arithmetic can produce results like 11.249999999999998. Multiplying by 100, rounding, then dividing by 100 ensures exactly 2 decimal places for currency.

### Snapshot Pattern for Immutability

[Source: architecture.md#Data Models - ServiceLog]

**Design Decision:** Price and commission rate are snapshotted at logging time to ensure historical accuracy. If a service price increases from $25 to $30, or a barber's commission rate changes from 45% to 50%, existing service logs must retain the original values used at the time of service completion.

**Why Immutability Matters:**

- Payroll integrity: Barbers expect commissions based on agreed rate at time of service
- Financial auditing: Historical reports must remain accurate
- Dispute resolution: Original values provide audit trail

**Implementation in Service Logging:**

```typescript
export async function logServices(
  barberId: string,
  serviceIds: string[]
): Promise<ServiceLog[]> {
  // Fetch barber's current commission rate (snapshot)
  const barber = await getBarberById(barberId)
  const commissionRate = barber.commissionRate

  const logs = await Promise.all(
    serviceIds.map(async (serviceId) => {
      // Fetch service's current price (snapshot)
      const service = await getServiceById(serviceId)
      const price = service.price

      // Calculate commission using snapshotted values
      const commissionAmount = calculateCommission(price, commissionRate)

      return {
        barberId,
        serviceId,
        price, // Snapshotted - immutable
        commissionRate, // Snapshotted - immutable
        commissionAmount, // Calculated from snapshots
        status: 'pending',
        createdAt: serverTimestamp(),
        approvedAt: null,
        rejectedAt: null,
      }
    })
  )

  // Batch write to Firestore
  return await createServiceLogs(logs)
}
```

### TypeScript Type Safety

[Source: architecture.md#Coding Standards - Critical Fullstack Rules]

**Type Definition:**

```typescript
// types/firestore.ts
interface ServiceLog {
  id: string
  barberId: string
  serviceId: string
  price: number // Explicitly number (not string)
  commissionRate: number // Explicitly number (not string)
  commissionAmount: number // Explicitly number (not string)
  status: 'pending' | 'approved' | 'rejected'
  createdAt: Firestore.Timestamp
  approvedAt: Firestore.Timestamp | null
  rejectedAt: Firestore.Timestamp | null
}
```

**Why No String Math:** TypeScript enforces numeric types to prevent accidental string concatenation (e.g., "25" + "10" = "2510" instead of 35). All calculations must use `number` type.

### Validation Schema

[Source: architecture.md#Coding Standards - Form Validation]

Use Zod for runtime validation of service log creation:

```typescript
// lib/validations/service-log-schema.ts
import { z } from 'zod'

export const createServiceLogSchema = z.object({
  barberId: z.string().min(1, 'Barber ID required'),
  serviceId: z.string().min(1, 'Service ID required'),
  price: z.number().positive('Price must be positive'),
  commissionRate: z
    .number()
    .min(0)
    .max(1, 'Commission rate must be between 0 and 1'),
  commissionAmount: z.number().min(0),
  status: z.enum(['pending', 'approved', 'rejected']),
})
```

### Firestore Data Model

[Source: architecture.md#Database Schema - Collection: serviceLogs]

**ServiceLog Document Structure:**

```json
{
  "id": "log_def456",
  "barberId": "abc123uid",
  "serviceId": "service_xyz789",
  "price": 25.0,
  "commissionRate": 0.45,
  "commissionAmount": 11.25,
  "status": "approved",
  "createdAt": "2025-10-09T14:30:00Z",
  "approvedAt": "2025-10-09T15:00:00Z",
  "rejectedAt": null
}
```

**Firestore Data Types:**

- price: number (Firestore stores as double)
- commissionRate: number (Firestore stores as double)
- commissionAmount: number (Firestore stores as double)

### Integration Points

[Source: architecture.md#Components]

**Usage Locations:**

1. **Barber Service Logging** (Story 3.2): `logServices()` function calls `calculateCommission()` for each selected service
2. **Manager Log on Behalf** (Story 3.9): `logServiceForBarber()` calls `calculateCommission()`
3. **Barber Daily Stats** (Story 3.4): Displays sum of `commissionAmount` from approved logs
4. **Financial Ledger** (Epic 4): Displays `commissionAmount` per transaction row
5. **Reports & Leaderboards** (Epic 5): Aggregates `commissionAmount` for rankings and totals

### Testing

**Unit Tests Required:**
[Source: architecture.md#Testing Strategy - Frontend Unit Tests]

1. **calculateCommission() Function Test** (`tests/unit/utils/calculations.test.ts`)
   - Test: $50 × 0.45 = $22.50
   - Test: $100 × 0.50 = $50.00
   - Test: $25 × 0.45 = $11.25
   - Test: $0 × 0.45 = $0.00 (edge case)
   - Test: $100 × 0 = $0.00 (manager with no commission)
   - Test: $33.33 × 0.333 = $11.10 (rounding test)
   - Test: $10.99 × 0.15 = $1.65 (two-decimal precision)
   - Test: Large numbers don't overflow (e.g., $999999 × 0.99)

**Example Test:**

```typescript
import { describe, it, expect } from 'vitest'
import { calculateCommission } from '@/lib/utils/calculations'

describe('calculateCommission', () => {
  it('calculates commission correctly for $50 at 45%', () => {
    expect(calculateCommission(50, 0.45)).toBe(22.5)
  })

  it('calculates commission correctly for $100 at 50%', () => {
    expect(calculateCommission(100, 0.5)).toBe(50.0)
  })

  it('returns 0 when commission rate is 0', () => {
    expect(calculateCommission(100, 0)).toBe(0)
  })

  it('rounds to 2 decimal places', () => {
    expect(calculateCommission(33.33, 0.333)).toBe(11.1)
  })
})
```

2. **Snapshot Immutability Test** (`tests/unit/services/service-logging.test.ts`)
   - Create service log with price $25, rate 0.45
   - Update service price to $30 in database
   - Update barber commission rate to 0.50 in database
   - Verify service log still has original price $25 and rate 0.45
   - Verify commissionAmount remains $11.25 (not recalculated)

3. **Validation Schema Test** (`tests/unit/validations/service-log-schema.test.ts`)
   - Valid data passes validation
   - Negative price fails validation
   - Commission rate > 1.0 fails validation
   - Commission rate < 0 fails validation
   - String values for numeric fields fail validation

**Integration Test:** 4. **End-to-End Commission Flow Test** (`tests/e2e/commission-accuracy.spec.ts`)

- Barber logs service with known price/rate
- Verify correct commission displayed in barber dashboard
- Manager approves log
- Change service price and barber commission rate
- Verify original log still shows original commission
- Create new log with same service/barber
- Verify new log uses updated price/rate (different commission)

## Change Log

| Date       | Version | Description            | Author          |
| ---------- | ------- | ---------------------- | --------------- |
| 2025-10-10 | v1.0    | Initial story creation | PM Agent (John) |

## Dev Agent Record

### Agent Model Used

{To be populated by dev agent}

### Debug Log References

{To be populated by dev agent}

### Completion Notes List

{To be populated by dev agent}

### File List

{To be populated by dev agent}

## QA Results

{To be populated by QA agent}
