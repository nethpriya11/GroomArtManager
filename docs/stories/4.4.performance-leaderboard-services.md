# Story 4.4: Performance Leaderboard - Top Services

## Status

Draft

## Story

**As a** manager,
**I want** to see which services are most popular and generate the most revenue,
**so that** I can optimize pricing and marketing.

## Acceptance Criteria

1. Reports page includes "Top Services" leaderboard table next to "Top Barbers"
2. Tables displayed side-by-side on desktop (>1024px), stacked on mobile (<1024px)
3. Columns: Rank, Service (name), Count (# of times logged), Revenue ($XXX.XX)
4. Data aggregated from service logs: Group by serviceId, sum prices, count logs (status = approved, within date range)
5. Sorted by revenue descending (highest revenue service at #1)
6. Top 10 services displayed by default
7. "View All" button expands table
8. Real-time updates: Rankings change as services logged
9. Service price displayed next to name (current price, not historical)
10. Responsive: Tables scroll horizontally on small screens if needed

## Tasks / Subtasks

- [ ] Create service leaderboard aggregation function (AC: 4, 5)
  - [ ] Implement `getTopServices(dateRange, limit)` in `lib/services/reporting-service.ts`
  - [ ] Query serviceLogs where status='approved' within date range
  - [ ] Group by serviceId using Map or reduce operation
  - [ ] For each service: calculate total revenue (sum prices) and count
  - [ ] Sort by revenue descending
  - [ ] Return top N services (default 10, expandable to all)
  - [ ] Include service details: id, name, currentPrice, revenue, count
- [ ] Create custom hook for real-time service leaderboard (AC: 8)
  - [ ] Implement `useTopServices(dateRange, limit)` in `hooks/useTopServices.ts`
  - [ ] Wrap `getTopServices()` with React Query and onSnapshot listener
  - [ ] Re-query when date range changes or limit changes
  - [ ] Handle real-time ranking updates when services logged
  - [ ] Configure staleTime: Infinity for real-time data
- [ ] Build service leaderboard table component (AC: 1, 3, 6, 9)
  - [ ] Create `TopServicesTable.tsx` in `components/reports/`
  - [ ] Define table columns: Rank, Service (name), Count, Revenue
  - [ ] Use ShadCN Table component for styling
  - [ ] Display rank as #1, #2, #3, etc.
  - [ ] Show service name with current price next to it
  - [ ] Format revenue as currency ($XXX.XX)
  - [ ] Limit to top 10 by default
- [ ] Implement "View All" expansion (AC: 6, 7)
  - [ ] Add "View All" button below table
  - [ ] Toggle limit between 10 and unlimited on button click
  - [ ] Button text changes to "Show Top 10" when expanded
  - [ ] Smooth transition when expanding/collapsing
- [ ] Implement responsive layout (AC: 2, 10)
  - [ ] Desktop (>1024px): Display TopBarbersTable and TopServicesTable side-by-side
  - [ ] Use CSS Grid: 2 columns with equal width
  - [ ] Mobile (<1024px): Stack tables vertically
  - [ ] Tables scroll horizontally on small screens if needed
  - [ ] Test on various screen sizes (320px, 768px, 1024px, 1440px)
- [ ] Integrate leaderboard into reports page (AC: 1, 2)
  - [ ] Add TopServicesTable next to TopBarbersTable in `app/manager/reports/page.tsx`
  - [ ] Wrap both tables in responsive grid container
  - [ ] Pass selected date range to table component
  - [ ] Ensure consistent styling between both leaderboards
- [ ] Handle empty state (AC: 8)
  - [ ] Display "No services logged in selected date range" when no data
  - [ ] Show empty state component (not error)
  - [ ] Maintain table structure with empty message
- [ ] Implement loading state (AC: 8)
  - [ ] Create skeleton loader for table rows
  - [ ] Show 10 skeleton rows while data loading
  - [ ] Use ShadCN Skeleton component
  - [ ] Sync loading state with barber leaderboard for consistency
- [ ] Display current service price (AC: 9)
  - [ ] Fetch current price from services collection
  - [ ] Display next to service name (e.g., "Haircut ($25.00)")
  - [ ] Note: This is current price, not historical price from logs
  - [ ] Handle case where service may be deleted (show "N/A")
- [ ] Test real-time ranking updates (AC: 8)
  - [ ] Log new service, verify ranking updates
  - [ ] Test ranking shift when multiple services logged
  - [ ] Verify updates appear within <2s latency
  - [ ] Test with date range filter applied

## Dev Notes

### Service Leaderboard Aggregation

[Source: architecture.md#Reporting & Analytics Service]

The `getTopServices()` function aggregates service logs by service and ranks them by revenue:

**Implementation Pattern:**

```typescript
export async function getTopServices(
  dateRange: DateRange,
  limit: number = 10
): Promise<ServiceLeaderboardEntry[]> {
  const db = getFirestore()

  // Query approved logs within date range
  const logsQuery = query(
    collection(db, 'serviceLogs'),
    where('status', '==', 'approved'),
    where('createdAt', '>=', Timestamp.fromDate(dateRange.from)),
    where('createdAt', '<=', Timestamp.fromDate(dateRange.to))
  )

  const snapshot = await getDocs(logsQuery)

  // Group by serviceId
  const serviceStats = new Map<string, { revenue: number; count: number }>()

  snapshot.docs.forEach((doc) => {
    const log = doc.data()
    const existing = serviceStats.get(log.serviceId) || { revenue: 0, count: 0 }
    serviceStats.set(log.serviceId, {
      revenue: existing.revenue + log.price,
      count: existing.count + 1,
    })
  })

  // Fetch service details (current price) and combine with stats
  const serviceEntries = await Promise.all(
    Array.from(serviceStats.entries()).map(async ([serviceId, stats]) => {
      const serviceDoc = await getDoc(doc(db, 'services', serviceId))
      const service = serviceDoc.data() as Service
      return {
        serviceId,
        serviceName: service.name,
        currentPrice: service.price, // Current price, not historical
        revenue: stats.revenue,
        count: stats.count,
      }
    })
  )

  // Sort by revenue descending and limit
  return serviceEntries.sort((a, b) => b.revenue - a.revenue).slice(0, limit)
}
```

### Real-time Updates

[Source: architecture.md#Real-time Sync Engine]

Use onSnapshot listener to detect ranking changes:

```typescript
export function useTopServices(dateRange: DateRange, limit: number = 10) {
  return useQuery({
    queryKey: ['top-services', dateRange.from, dateRange.to, limit],
    queryFn: () =>
      new Promise((resolve) => {
        const logsQuery = query(
          collection(db, 'serviceLogs'),
          where('status', '==', 'approved'),
          where('createdAt', '>=', Timestamp.fromDate(dateRange.from)),
          where('createdAt', '<=', Timestamp.fromDate(dateRange.to))
        )

        const unsubscribe = onSnapshot(logsQuery, async (snapshot) => {
          // Recalculate leaderboard on each update
          const leaderboard = await calculateServiceLeaderboardFromSnapshot(
            snapshot,
            limit
          )
          resolve(leaderboard)
        })

        return () => unsubscribe()
      }),
    staleTime: Infinity,
  })
}
```

### Data Models

[Source: architecture.md#Data Models]

**ServiceLog:**

- `serviceId`: string - References service ID
- `price`: number - Snapshot of service price at logging time (used for revenue)
- `status`: 'pending' | 'approved' | 'rejected'
- `createdAt`: Firestore Timestamp

**Service:**

- `name`: string - Service name (e.g., "Haircut")
- `price`: number - Current service price (may differ from historical logs)
- `duration`: number - Service duration in minutes

### Responsive Layout

[Source: architecture.md#Coding Standards]

Desktop (>1024px) - Side-by-side layout:

```tsx
<div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
  <TopBarbersTable dateRange={dateRange} />
  <TopServicesTable dateRange={dateRange} />
</div>
```

Mobile (<1024px) - Stacked layout:

- Tables automatically stack vertically using grid-cols-1
- Each table scrolls horizontally if content exceeds viewport
- Use Tailwind `overflow-x-auto` for horizontal scroll

### Table Styling

- Use ShadCN Table component for consistency with TopBarbersTable
- Dark theme: #1a1a1a background, #f59e0b accents for top 3 ranks
- Rank column: Bold font, highlight #1, #2, #3 with accent color
- Revenue column: Right-aligned, formatted as currency
- Count column: Right-aligned, formatted as number
- Service name column: Left-aligned with current price in muted text

### Current vs Historical Price

**Important Note:**

- Service logs store snapshot of price at logging time (`log.price`)
- Revenue calculation uses historical snapshot prices (accurate for past transactions)
- Current price displayed next to service name is from services collection (`service.price`)
- Current price may differ from historical prices if service price changed

**Display Format:**

```
Service Name              Count    Revenue
------------------------  -------  ----------
Haircut ($25.00)         45       $1,125.00
Beard Trim ($15.00)      30       $450.00
```

### Testing

[Source: architecture.md#Testing Strategy]

#### Component Tests

**Location:** `tests/component/reports/TopServicesTable.test.tsx`

Test cases:

1. Renders table with correct columns
2. Displays service name with current price
3. Formats revenue as currency
4. Shows rank numbers correctly (#1, #2, #3)
5. Limits to top 10 by default
6. "View All" button expands to show all services
7. Displays empty state when no data
8. Shows loading skeleton while fetching

**Example:**

```typescript
describe('TopServicesTable', () => {
  it('displays top services ranked by revenue', () => {
    const mockData = [
      { serviceId: '1', serviceName: 'Haircut', currentPrice: 25, revenue: 1000, count: 40 },
      { serviceId: '2', serviceName: 'Shave', currentPrice: 15, revenue: 600, count: 40 },
    ];

    render(<TopServicesTable data={mockData} />);

    // Verify rank order
    expect(screen.getByText('#1')).toBeInTheDocument();
    expect(screen.getByText('#2')).toBeInTheDocument();

    // Verify service name with current price
    expect(screen.getByText(/Haircut.*\$25\.00/)).toBeInTheDocument();
    expect(screen.getByText(/Shave.*\$15\.00/)).toBeInTheDocument();

    // Verify revenue formatting
    expect(screen.getByText('$1,000.00')).toBeInTheDocument();
    expect(screen.getByText('$600.00')).toBeInTheDocument();
  });
});
```

#### Responsive Layout Tests

**Location:** `tests/component/reports/ReportsPage.test.tsx`

Test cases:

1. Desktop (>1024px): Leaderboards displayed side-by-side
2. Mobile (<1024px): Leaderboards stacked vertically
3. Tables scroll horizontally on small screens
4. Layout adjusts smoothly when resizing window

**Example:**

```typescript
describe('ReportsPage responsive layout', () => {
  it('displays leaderboards side-by-side on desktop', () => {
    // Mock desktop viewport
    window.innerWidth = 1440;

    render(<ReportsPage />);

    const container = screen.getByTestId('leaderboards-container');
    expect(container).toHaveClass('lg:grid-cols-2');
  });

  it('stacks leaderboards on mobile', () => {
    // Mock mobile viewport
    window.innerWidth = 375;

    render(<ReportsPage />);

    const container = screen.getByTestId('leaderboards-container');
    expect(container).toHaveClass('grid-cols-1');
  });
});
```

#### Integration Tests

**Location:** `tests/component/reports/ReportsPage.test.tsx`

Test cases:

1. Both leaderboards update when date range changes
2. Rankings recalculated when new services logged
3. Both leaderboards use same date range filter
4. Loading states sync between barber and service tables

#### E2E Tests

**Location:** `tests/e2e/reports.spec.ts`

Test cases:

1. Manager views reports page with both leaderboards
2. Verify top 10 services displayed
3. Verify side-by-side layout on desktop
4. Resize to mobile, verify stacked layout
5. Click "View All", verify all services shown
6. Log new service, verify rankings update in real-time
7. Change date range, verify both leaderboards update

**Test Flow:**

```typescript
test('Service leaderboard shows real-time ranking updates', async ({
  page,
}) => {
  await page.goto('/manager/reports')

  // Verify both leaderboards loaded
  await expect(page.locator('[data-testid="top-barbers-table"]')).toBeVisible()
  await expect(page.locator('[data-testid="top-services-table"]')).toBeVisible()

  // Record rank #1 service
  const topService = await page
    .locator('[data-testid="service-rank-1-name"]')
    .textContent()

  // Log multiple instances of a different service
  await page.goto('/barber/dashboard')
  // (Log service multiple times to increase its revenue)

  // Navigate back to reports
  await page.goto('/manager/reports')

  // Verify rankings may have shifted
  await expect(page.locator('[data-testid="top-services-table"]')).toBeVisible()
})

test('Responsive layout: leaderboards side-by-side on desktop', async ({
  page,
}) => {
  await page.setViewportSize({ width: 1440, height: 900 })
  await page.goto('/manager/reports')

  // Verify both tables visible and positioned side-by-side
  const barbersTable = page.locator('[data-testid="top-barbers-table"]')
  const servicesTable = page.locator('[data-testid="top-services-table"]')

  const barbersBox = await barbersTable.boundingBox()
  const servicesBox = await servicesTable.boundingBox()

  // Tables should have similar Y position (side-by-side)
  expect(Math.abs(barbersBox.y - servicesBox.y)).toBeLessThan(50)
})

test('Responsive layout: leaderboards stacked on mobile', async ({ page }) => {
  await page.setViewportSize({ width: 375, height: 667 })
  await page.goto('/manager/reports')

  // Verify both tables visible and stacked vertically
  const barbersTable = page.locator('[data-testid="top-barbers-table"]')
  const servicesTable = page.locator('[data-testid="top-services-table"]')

  const barbersBox = await barbersTable.boundingBox()
  const servicesBox = await servicesTable.boundingBox()

  // Services table should be below barbers table
  expect(servicesBox.y).toBeGreaterThan(barbersBox.y + barbersBox.height)
})
```

#### Unit Tests

**Location:** `tests/unit/services/reporting-service.test.ts`

Test cases:

1. `getTopServices()` groups logs by serviceId correctly
2. Calculates total revenue per service (sum of log prices)
3. Counts service occurrences correctly
4. Sorts services by revenue descending
5. Limits to top N services
6. Fetches current service details (name, price) from services collection
7. Filters only approved logs within date range
8. Returns empty array when no logs in range
9. Handles deleted services gracefully (service doc doesn't exist)

**Example:**

```typescript
describe('getTopServices', () => {
  it('ranks services by revenue descending', async () => {
    // Mock service logs
    mockGetDocs.mockResolvedValue({
      docs: [
        {
          data: () => ({
            serviceId: 'service1',
            price: 25,
            status: 'approved',
          }),
        },
        {
          data: () => ({
            serviceId: 'service2',
            price: 15,
            status: 'approved',
          }),
        },
        {
          data: () => ({
            serviceId: 'service1',
            price: 25,
            status: 'approved',
          }),
        },
      ],
    })

    // Mock service details
    mockGetDoc.mockImplementation((docRef) => {
      if (docRef.id === 'service1') {
        return Promise.resolve({ data: () => ({ name: 'Haircut', price: 25 }) })
      }
      return Promise.resolve({ data: () => ({ name: 'Shave', price: 15 }) })
    })

    const dateRange = { from: subDays(new Date(), 7), to: new Date() }
    const leaderboard = await getTopServices(dateRange, 10)

    // Verify ranking
    expect(leaderboard[0].serviceId).toBe('service1') // $50 total
    expect(leaderboard[0].revenue).toBe(50)
    expect(leaderboard[0].count).toBe(2)
    expect(leaderboard[1].serviceId).toBe('service2') // $15
    expect(leaderboard[1].revenue).toBe(15)
    expect(leaderboard[1].count).toBe(1)
  })
})
```

## Change Log

| Date       | Version | Description            | Author          |
| ---------- | ------- | ---------------------- | --------------- |
| 2025-10-10 | v1.0    | Initial story creation | PM Agent (John) |

## Dev Agent Record

### Agent Model Used

{To be populated by dev agent}

### Debug Log References

{To be populated by dev agent}

### Completion Notes List

{To be populated by dev agent}

### File List

{To be populated by dev agent}

## QA Results

{To be populated by QA agent}
