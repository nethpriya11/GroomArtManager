# Story 4.8: Barber Daily Stats on Barber Cards

## Status

Draft

## Story

**As a** manager,
**I want** to see each barber's daily performance on their profile card,
**so that** I can quickly identify who's working and who's idle.

## Acceptance Criteria

1. Barber cards on `/manager/barbers` page display daily stats below barber name
2. Stats shown: "Services Today: X | Revenue Today: $XX.XX"
3. Stats calculated from service logs: barberId matches, status = approved, createdAt is today
4. Real-time updates: Stats increment when services approved
5. Stats reset at midnight local time
6. If no services today: Shows "Services Today: 0 | Revenue Today: $0.00"
7. Stats styled with smaller font (14px), muted color (#9ca3af)
8. Stats use same calculation logic as barber dashboard daily stats (consistency)
9. Query optimized: Uses Firestore index
10. Clicking a barber card could navigate to detailed barber report (stretch goal - not MVP)

## Tasks / Subtasks

- [ ] Add daily stats display to barber cards (AC: 1, 2, 7)
  - [ ] Update BarberCard component on `/manager/barbers` page
  - [ ] Add stats section below barber name
  - [ ] Display format: "Services Today: X | Revenue Today: $XX.XX"
  - [ ] Style with smaller font (14px), muted color (#9ca3af)
- [ ] Implement daily stats calculation query (AC: 3, 9)
  - [ ] Query serviceLogs collection: barberId matches, status = 'approved', createdAt is today
  - [ ] Use Firestore composite index: barberId + status + createdAt
  - [ ] Calculate services count: count of matching logs
  - [ ] Calculate revenue: sum of price field from matching logs
- [ ] Set up real-time updates (AC: 4)
  - [ ] Use Firestore onSnapshot listener for daily stats
  - [ ] Stats increment immediately when services approved
  - [ ] Wrap listener in React Query for caching and cleanup
- [ ] Implement midnight reset logic (AC: 5)
  - [ ] Calculate "today" date range: startOfDay to endOfDay (local time)
  - [ ] Use date-fns for date calculations
  - [ ] Firestore query automatically filters by date, stats reset at midnight
- [ ] Handle zero stats case (AC: 6)
  - [ ] Display "Services Today: 0 | Revenue Today: $0.00" when no services
  - [ ] No error or empty state, just show zero values
- [ ] Ensure consistency with barber dashboard (AC: 8)
  - [ ] Reuse same calculation logic as barber dashboard daily stats
  - [ ] Extract shared hook: useDailyStats(barberId)
  - [ ] Same query structure and data formatting
- [ ] Add stretch goal: Navigate to barber report (AC: 10 - optional)
  - [ ] Make barber card clickable
  - [ ] Navigate to `/manager/barbers/[barberId]` detail page (if implemented)
  - [ ] Show cursor pointer on hover

## Dev Notes

### Barber Card Component Enhancement

[Source: architecture.md#Components - Atomic Design]

**Component Structure:**

```
components/
└── features/
    └── barbers/
        ├── BarberCard.tsx         # Updated with daily stats
        └── BarberDailyStats.tsx   # Subcomponent for stats display
```

**Updated BarberCard Layout:**

```typescript
import { BarberDailyStats } from './BarberDailyStats';

function BarberCard({ barber }: { barber: UserProfile }) {
  return (
    <Card>
      <CardHeader>
        <Avatar src={barber.avatarUrl} />
        <h3>{barber.username}</h3>
        <Badge>{barber.role}</Badge>
      </CardHeader>
      <CardContent>
        <p>Commission: {(barber.commissionRate * 100).toFixed(0)}%</p>
        <BarberDailyStats barberId={barber.id} />
      </CardContent>
    </Card>
  );
}
```

### Daily Stats Calculation Hook

[Source: architecture.md#Data Models - ServiceLog]

**Shared Hook Pattern:**

```typescript
// hooks/useDailyStats.ts
import { useMemo } from 'react'
import { useQuery } from '@tanstack/react-query'
import {
  collection,
  query,
  where,
  onSnapshot,
  Timestamp,
} from 'firebase/firestore'
import { startOfDay, endOfDay } from 'date-fns'
import { db } from '@/lib/firebase/config'

export function useDailyStats(barberId: string) {
  const today = useMemo(() => {
    const now = new Date()
    return {
      start: Timestamp.fromDate(startOfDay(now)),
      end: Timestamp.fromDate(endOfDay(now)),
    }
  }, []) // Recalculate only on mount (date won't change during session)

  return useQuery({
    queryKey: ['dailyStats', barberId, today.start.toMillis()],
    queryFn: () =>
      new Promise((resolve) => {
        const q = query(
          collection(db, 'serviceLogs'),
          where('barberId', '==', barberId),
          where('status', '==', 'approved'),
          where('createdAt', '>=', today.start),
          where('createdAt', '<=', today.end)
        )

        const unsubscribe = onSnapshot(q, (snapshot) => {
          const logs = snapshot.docs.map((doc) => doc.data())
          const stats = {
            servicesCount: logs.length,
            revenue: logs.reduce((sum, log) => sum + log.price, 0),
          }
          resolve(stats)
        })

        return () => unsubscribe()
      }),
    staleTime: Infinity, // Real-time data never stale
  })
}
```

**Usage in BarberDailyStats Component:**

```typescript
function BarberDailyStats({ barberId }: { barberId: string }) {
  const { data: stats, isLoading } = useDailyStats(barberId);

  if (isLoading) {
    return <Skeleton className="h-4 w-48" />;
  }

  const servicesCount = stats?.servicesCount ?? 0;
  const revenue = stats?.revenue ?? 0;

  return (
    <p className="text-sm text-muted-foreground">
      Services Today: {servicesCount} | Revenue Today: ${revenue.toFixed(2)}
    </p>
  );
}
```

### Firestore Query Optimization

[Source: architecture.md#Performance Optimization - Database]

**Required Composite Index:**

```json
// firestore.indexes.json
{
  "indexes": [
    {
      "collectionGroup": "serviceLogs",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "barberId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "ASCENDING" }
      ]
    }
  ]
}
```

**Index Rationale:**

- Query filters by barberId, status, and createdAt range
- Firestore requires index for queries with multiple where() clauses
- Index enables fast lookups: O(log n) instead of O(n) collection scan

**Query Performance:**

- With index: ~50-100ms for 1000+ logs
- Without index: Query will fail with "requires index" error
- Firestore console will provide auto-generate link on first query

### Date Handling for Midnight Reset

[Source: architecture.md#Coding Standards - Date Handling]

**Today Date Range Calculation:**

```typescript
import { startOfDay, endOfDay } from 'date-fns'

// Calculate today's date range in local timezone
const todayStart = startOfDay(new Date()) // 00:00:00.000 today
const todayEnd = endOfDay(new Date()) // 23:59:59.999 today

// Convert to Firestore Timestamps
const startTimestamp = Timestamp.fromDate(todayStart)
const endTimestamp = Timestamp.fromDate(todayEnd)
```

**Midnight Reset Behavior:**

- Query filters createdAt >= startOfDay AND createdAt <= endOfDay
- When clock passes midnight (00:00), startOfDay/endOfDay recalculate
- useMemo dependency array is empty, so recalculation happens on component remount
- For automatic reset without remount, use:

  ```typescript
  // Option: Refresh stats at midnight
  useEffect(() => {
    const now = new Date()
    const tomorrow = startOfDay(new Date(now.getTime() + 86400000)) // Next day
    const msUntilMidnight = tomorrow.getTime() - now.getTime()

    const timer = setTimeout(() => {
      queryClient.invalidateQueries(['dailyStats'])
    }, msUntilMidnight)

    return () => clearTimeout(timer)
  }, [])
  ```

### Consistency with Barber Dashboard

[Source: architecture.md#Architecture Patterns - DRY Principle]

**Shared Logic:**
Both manager's barber cards and barber's dashboard use the same `useDailyStats` hook:

```typescript
// Manager's barber cards
<BarberCard barber={barber} />
  └─> <BarberDailyStats barberId={barber.id} />
       └─> useDailyStats(barber.id)

// Barber's dashboard
<BarberDashboard />
  └─> <DailyStatsCard />
       └─> useDailyStats(currentUser.id)
```

**Benefits:**

- Single source of truth for daily stats calculation
- Consistent results across UI (manager sees same numbers as barber)
- Easier testing (test hook once, not each component)
- Shared React Query cache (same query key structure)

### Testing

#### Unit Tests

[Source: architecture.md#Testing Strategy - Frontend Unit Tests]

**Test File:** `tests/unit/hooks/useDailyStats.test.ts`

**Test Cases:**

```typescript
import { renderHook, waitFor } from '@testing-library/react';
import { useDailyStats } from '@/hooks/useDailyStats';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

// Mock Firestore
vi.mock('@/lib/firebase/config', () => ({
  db: {}
}));

describe('useDailyStats', () => {
  const queryClient = new QueryClient();
  const wrapper = ({ children }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );

  it('calculates services count correctly', async () => {
    // Mock Firestore onSnapshot to return test data
    const mockLogs = [
      { price: 25, barberId: 'barber_1', status: 'approved' },
      { price: 30, barberId: 'barber_1', status: 'approved' }
    ];

    vi.mocked(onSnapshot).mockImplementation((query, callback) => {
      callback({ docs: mockLogs.map(log => ({ data: () => log })) });
      return () => {};
    });

    const { result } = renderHook(() => useDailyStats('barber_1'), { wrapper });

    await waitFor(() => expect(result.current.data).toBeDefined());

    expect(result.current.data.servicesCount).toBe(2);
  });

  it('calculates revenue correctly', async () => {
    const mockLogs = [
      { price: 25, barberId: 'barber_1', status: 'approved' },
      { price: 30, barberId: 'barber_1', status: 'approved' }
    ];

    vi.mocked(onSnapshot).mockImplementation((query, callback) => {
      callback({ docs: mockLogs.map(log => ({ data: () => log })) });
      return () => {};
    });

    const { result } = renderHook(() => useDailyStats('barber_1'), { wrapper });

    await waitFor(() => expect(result.current.data).toBeDefined());

    expect(result.current.data.revenue).toBe(55); // 25 + 30
  });

  it('returns zero stats when no services logged', async () => {
    vi.mocked(onSnapshot).mockImplementation((query, callback) => {
      callback({ docs: [] });
      return () => {};
    });

    const { result } = renderHook(() => useDailyStats('barber_1'), { wrapper });

    await waitFor(() => expect(result.current.data).toBeDefined());

    expect(result.current.data.servicesCount).toBe(0);
    expect(result.current.data.revenue).toBe(0);
  });

  it('filters by today date range', () => {
    const { result } = renderHook(() => useDailyStats('barber_1'), { wrapper });

    // Verify query was called with correct date range
    expect(vi.mocked(query)).toHaveBeenCalledWith(
      expect.anything(),
      expect.objectContaining({ barberId: 'barber_1' }),
      expect.objectContaining({ status: 'approved' }),
      expect.objectContaining({ fieldPath: 'createdAt', operator: '>=' }),
      expect.objectContaining({ fieldPath: 'createdAt', operator: '<=' })
    );
  });
});
```

#### Component Tests

[Source: architecture.md#Testing Strategy - Component Tests]

**Test File:** `tests/component/barbers/BarberDailyStats.test.tsx`

**Test Cases:**

```typescript
import { render, screen } from '@testing-library/react';
import { BarberDailyStats } from '@/components/features/barbers/BarberDailyStats';
import { useDailyStats } from '@/hooks/useDailyStats';

vi.mock('@/hooks/useDailyStats');

describe('BarberDailyStats', () => {
  it('displays services count and revenue', () => {
    vi.mocked(useDailyStats).mockReturnValue({
      data: { servicesCount: 5, revenue: 125 },
      isLoading: false
    });

    render(<BarberDailyStats barberId="barber_1" />);

    expect(screen.getByText(/Services Today: 5/i)).toBeInTheDocument();
    expect(screen.getByText(/Revenue Today: \$125\.00/i)).toBeInTheDocument();
  });

  it('displays zero values when no services', () => {
    vi.mocked(useDailyStats).mockReturnValue({
      data: { servicesCount: 0, revenue: 0 },
      isLoading: false
    });

    render(<BarberDailyStats barberId="barber_1" />);

    expect(screen.getByText(/Services Today: 0/i)).toBeInTheDocument();
    expect(screen.getByText(/Revenue Today: \$0\.00/i)).toBeInTheDocument();
  });

  it('shows skeleton loading state', () => {
    vi.mocked(useDailyStats).mockReturnValue({
      data: undefined,
      isLoading: true
    });

    render(<BarberDailyStats barberId="barber_1" />);

    expect(screen.getByTestId('skeleton')).toBeInTheDocument();
  });

  it('formats revenue with 2 decimal places', () => {
    vi.mocked(useDailyStats).mockReturnValue({
      data: { servicesCount: 3, revenue: 75.5 },
      isLoading: false
    });

    render(<BarberDailyStats barberId="barber_1" />);

    expect(screen.getByText(/\$75\.50/)).toBeInTheDocument();
  });

  it('uses muted text color style', () => {
    vi.mocked(useDailyStats).mockReturnValue({
      data: { servicesCount: 2, revenue: 50 },
      isLoading: false
    });

    const { container } = render(<BarberDailyStats barberId="barber_1" />);

    const statsText = container.querySelector('p');
    expect(statsText).toHaveClass('text-muted-foreground');
    expect(statsText).toHaveClass('text-sm'); // 14px
  });
});
```

#### E2E Tests

[Source: architecture.md#Testing Strategy - E2E Tests]

**Test File:** `tests/e2e/barber-management.spec.ts`

**Test Cases:**

```typescript
import { test, expect } from '@playwright/test'

test.describe('Barber Daily Stats on Cards', () => {
  test.beforeEach(async ({ page }) => {
    // Login as manager
    await page.goto('/login')
    await page.click('text=Manager')
    await page.goto('/manager/barbers')
  })

  test('displays daily stats on each barber card', async ({ page }) => {
    // Check first barber card has stats
    const firstCard = page.locator('[data-testid="barber-card"]').first()

    await expect(firstCard.locator('text=Services Today:')).toBeVisible()
    await expect(firstCard.locator('text=Revenue Today:')).toBeVisible()
  })

  test('shows zero stats when barber has no services today', async ({
    page,
  }) => {
    // Assuming there's a barber with no services
    const idleBarberCard = page
      .locator('[data-testid="barber-card"]:has-text("Services Today: 0")')
      .first()

    await expect(idleBarberCard).toContainText('Services Today: 0')
    await expect(idleBarberCard).toContainText('Revenue Today: $0.00')
  })

  test('updates stats in real-time when service approved', async ({
    page,
    context,
  }) => {
    // Open second browser as barber
    const barberPage = await context.newPage()
    await barberPage.goto('/login')
    await barberPage.click('text=Barber')
    await barberPage.click('text=John Barber')

    // Get initial stats for John Barber card
    const johnCard = page.locator(
      '[data-testid="barber-card"]:has-text("John Barber")'
    )
    const initialStats = await johnCard
      .locator('text=Services Today:')
      .textContent()
    const initialCount = parseInt(
      initialStats.match(/Services Today: (\d+)/)[1]
    )

    // Barber logs a service
    await barberPage.click('text=Haircut')
    await barberPage.click('button:has-text("Log 1 Service")')

    // Manager approves service
    await page.click('text=Pending Approvals')
    await page.click('[aria-label="Approve"]').first()

    // Navigate back to barbers page
    await page.goto('/manager/barbers')

    // Verify stats incremented
    await expect(johnCard.locator('text=Services Today:')).toContainText(
      `Services Today: ${initialCount + 1}`
    )

    await barberPage.close()
  })

  test('stats reset at midnight (simulate by refreshing next day)', async ({
    page,
  }) => {
    // This test would need to mock the date or run at specific times
    // For MVP, document that manual testing is required for midnight reset

    // Alternatively, test with mocked date:
    await page.addInitScript(() => {
      // Mock Date to simulate tomorrow
      const tomorrow = new Date()
      tomorrow.setDate(tomorrow.getDate() + 1)
      Date.now = () => tomorrow.getTime()
    })

    await page.reload()

    // Stats should reset (assuming no services logged "tomorrow")
    const cards = page.locator('[data-testid="barber-card"]')
    await expect(cards.first()).toContainText('Services Today: 0')
  })

  test('stats use same calculation as barber dashboard', async ({
    page,
    context,
  }) => {
    // Login as barber in new page
    const barberPage = await context.newPage()
    await barberPage.goto('/login')
    await barberPage.click('text=Barber')
    await barberPage.click('text=John Barber')

    // Get barber's daily stats from their dashboard
    const barberDashboardStats = await barberPage
      .locator('text=Services Today:')
      .textContent()

    // Get same barber's stats from manager's barber card
    const johnCard = page.locator(
      '[data-testid="barber-card"]:has-text("John Barber")'
    )
    const managerViewStats = await johnCard
      .locator('text=Services Today:')
      .textContent()

    // Should match exactly
    expect(barberDashboardStats).toBe(managerViewStats)

    await barberPage.close()
  })

  test('clicking barber card navigates to detail page (stretch goal)', async ({
    page,
  }) => {
    const firstCard = page.locator('[data-testid="barber-card"]').first()

    await firstCard.click()

    // Verify navigation to barber detail page (if implemented)
    await expect(page).toHaveURL(/\/manager\/barbers\/\w+/)
  })
})
```

#### Integration Tests

**Test that daily stats:**

- Calculate correctly with multiple services logged
- Update in real-time when services approved/rejected
- Reset at midnight (manual test or date mocking)
- Match barber dashboard stats exactly
- Handle edge cases: barber with no services, very high service counts (100+)

## Change Log

| Date       | Version | Description            | Author          |
| ---------- | ------- | ---------------------- | --------------- |
| 2025-10-10 | v1.0    | Initial story creation | PM Agent (John) |

## Dev Agent Record

### Agent Model Used

{To be populated by dev agent}

### Debug Log References

{To be populated by dev agent}

### Completion Notes List

{To be populated by dev agent}

### File List

{To be populated by dev agent}

## QA Results

{To be populated by QA agent}
